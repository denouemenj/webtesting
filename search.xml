<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Material主题</title>
      <link href="/2018/11/09/Hexo%E5%85%A5%E5%9D%91%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/09/Hexo%E5%85%A5%E5%9D%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Material主题"><a href="#Material主题" class="headerlink" title="Material主题"></a>Material主题</h1><p><a href="https://github.com/EasyHexo/Easy-Hexo" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Maintained--by-EasyHexo-42B983.svg?longCache=true&amp;style=flat-square" alt=""></a><br><a href="https://github.com/ffdy" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Author-ffy-800080.svg?longCache=true&amp;style=flat-square" alt=""></a></p><p>:::tip<br>注意，这里介绍的Material主题是1.5.2的版本，新手不建议使用最新的版本，因为好像有很多Bug（作者最近失联了）<br>:::</p><p><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">Material主题地址</a></p><h2 id="Material主题演示"><a href="#Material主题演示" class="headerlink" title="Material主题演示"></a>Material主题演示</h2><p><img src="https://camo.githubusercontent.com/1e9260f301fe915fb3e4826831fde943229523cb/68747470733a2f2f692e6c6f6c692e6e65742f323031372f30392f30372f353962313336376637366664622e706e67" alt="演示"></p><h2 id="下载Material主题"><a href="#下载Material主题" class="headerlink" title="下载Material主题"></a>下载Material主题</h2><ol><li><p>进入 Github，下载 <a href="https://github.com/viosey/hexo-theme-material/releases" target="_blank" rel="noopener">Material</a> 主题 1.5.2 的版本。</p></li><li><p>将下载下来的主题解压，将解压的文件夹重命名为 <code>Material</code>。</p></li><li><p>将这个文件夹放到你的博客根目录下的 themes 文件夹下。</p></li></ol><p><img src="https://s1.ax1x.com/2018/10/27/i6XOpT.png" alt="i6XOpT.png"></p><h2 id="启用Material主题"><a href="#启用Material主题" class="headerlink" title="启用Material主题"></a>启用Material主题</h2><p>:::tip<br>这里有两个 <code>_config.yml</code> 文件，一个位于博客根目录,另一个位于主题文件夹下，下面分别叫他们<code>根 _config.yml</code>文件和<code>主题 _config.yml</code>文件。<br>:::</p><p>进入Material文件夹,将<code>_config.template.yml</code> 重命名为 <code>_config.yml</code><br>（这个 <code>_config.yml</code> 文件是 <code>主题_config.yml</code> 文件）</p><p>:::tip<br>建议你将 <code>_config.template.yml</code> 文件备份，防止一些不可描述的的问题。<br>:::</p><p><img src="https://s1.ax1x.com/2018/10/27/i6x8mQ.png" alt="i6x8mQ.png"></p><p>回到主题根目录，打开<code>根 _config.yml</code>文件，找到 <code>theme</code> 属性</p><p><img src="https://s1.ax1x.com/2018/10/27/i6zA3V.png" alt="i6zA3V.png"><br><img src="https://s1.ax1x.com/2018/10/27/i6Lih8.md.png" alt="i6Lih8.md.png"></p><p>将后面的字段改为你刚刚改的主题文件夹的名字，比如我的<code>Material</code>。<br>:::tip</p><p>在 yml 中，冒号后面必须加一个空格，否则会报错。</p><p>:::</p><p>OK，Material 主题就正式启用了下面，就是见证奇迹的时候了，有没有一点小激动呢?</p><p>回到博客根目录，打开终端，输入:</p><pre><code class="lang-brash">$ hexo clean</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPF6P.png" alt="icPF6P.png"></p><p>完美！！！:tada:</p><p>好，再输入:</p><pre><code class="lang-brash">$ hexo g</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPQlq.png" alt="icPQlq.png"></p><p>完全OK！！！:tada:</p><p>输入:</p><pre><code class="lang-brash">$ hexo s</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPqhj.png" alt="icPqhj.png"></p><p>打开浏览器输入<code>http://localhost:4000</code>，即可看见你博客的样子。</p><p><img src="https://s1.ax1x.com/2018/10/27/icPW9A.png" alt="icPW9A.png"><br><img src="https://s1.ax1x.com/2018/10/27/icP2hd.png" alt="icP2hd.png"></p><p>点片文章试试，如果没问题，那么恭喜你！<br>:tada: :tada: :tada: :tada:</p><p>如果你想让你的Blog马力全开,那么请继续往下看</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>本站公告</title>
      <link href="/2018/10/26/%E6%9C%AC%E7%AB%99%E5%85%AC%E5%91%8A/"/>
      <url>/2018/10/26/%E6%9C%AC%E7%AB%99%E5%85%AC%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到FFY’s-Blog"><a href="#欢迎来到FFY’s-Blog" class="headerlink" title="欢迎来到FFY’s Blog"></a>欢迎来到FFY’s Blog</h1><p>这是我用HEXO搭建在的github上的一个Blog,因此,图片的加载可能有点慢<br>目前,本站的功能还在继续更新<br>如果你有什么好的建议,欢迎在最下方的评论留下你的昵称,邮箱和想法,或者直接<a href="https://ffdy.github.io/about/">联系我</a><br><br><br><br><br>本站的文章都比较水 <del>(好吧,是水的不要不要的)</del> ,请大佬勿喷</p><p>如果你对HEXO静态Blog感兴趣,请直接联系我,我会尽我所能帮助你</p><h3 id="本站的功能清单"><a href="#本站的功能清单" class="headerlink" title="本站的功能清单:"></a>本站的功能清单:</h3><ul><li>鼠标点击效果</li><li>页面欺骗</li><li>Live2D宠物</li><li>Markdown</li><li>mathjax数学公式</li><li>mermaid图表</li><li>语法高亮</li><li>评论系统</li><li>分享系统</li><li>站内搜索</li><li>文章置顶</li><li>随机图片</li><li>文章标签</li><li>文章分类</li></ul><p>我是疯疯芸,你也可以叫我FFY,感谢你的来访</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>信息技术培训基础知识</title>
      <link href="/2018/10/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/10/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、高精度计算"><a href="#一、高精度计算" class="headerlink" title="一、高精度计算"></a>一、高精度计算</h3><p>（至少掌握加减乘（高精对高精），正数高精度（简化模板）加减乘除（高精度与低精度）  </p><h3 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h3><p>基本算法（选择排序、插入排序、冒泡排序、快排、堆排、归并排序、计数排序、基数排序。另外练习字符串排序、多关健字排序、排序二叉树）<br>典型应用<br>逆序对、第K小数  </p><h3 id="三、查找算法"><a href="#三、查找算法" class="headerlink" title="三、查找算法"></a>三、查找算法</h3><p>数组映射、顺序查找、二分查找（一般静态）、hash查找（可动态也可静态、编码）  </p><h3 id="四、递归、回溯、深搜"><a href="#四、递归、回溯、深搜" class="headerlink" title="四、递归、回溯、深搜"></a>四、递归、回溯、深搜</h3><p>从相关题目加深理解<br>最大公约数（减法和求余）、排列数的输出、组合数的输出、表达式计算、逆波兰式、连续最大和（递归）、上台阶问题、跳马问题、填数问题、老鼠走迷宫、因式分解、素数环、皇后问题、机器分工、数的划分、任务安排、四色问题、邮票问题、埃及分数、生日蛋糕、八数码问题、路由选择。（迭代思想、剪枝技巧、IDA*、阶乘编码）  </p><h3 id="五、广搜"><a href="#五、广搜" class="headerlink" title="五、广搜"></a>五、广搜</h3><p>魔板问题、跳棋问题、八数码问题、奇怪的电梯、翻硬币问题。（相关的优化，加快判重、双向搜索、IDA*）  </p><h3 id="六、二分"><a href="#六、二分" class="headerlink" title="六、二分"></a>六、二分</h3><p>二分加速、二分查找、二分枚举  </p><h3 id="七、数据结构"><a href="#七、数据结构" class="headerlink" title="七、数据结构"></a>七、数据结构</h3><p>栈（表达式计算）、队列（广搜中常用、单调队列）、链表、双向链表、堆、竞赛树、排序二叉树、树状数组、hash、并查集、KMP算法、RMQ、LCA、回文串问题、trie。（树的线型化应用、深搜序的应用）  </p><h3 id="八、图论"><a href="#八、图论" class="headerlink" title="八、图论"></a>八、图论</h3><p>图的两种遍历方式、图的连通性判别定（深搜索、并查集）、有向图的强连通分量（两次深搜求交法、tarjan)、拓朴排序、关键路、最短路算法（dijk、floyd、bellman、spfa)、最小生成树（prime、Kruskal）二分匹配（最大独立集、最小支配集、最小路径点覆盖问题）（题库上题目较多）欧拉路和欧拉回路、哈密顿回路、关节点、桥  </p><h3 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h3><p>（重中之重 练习相关基本模型）  </p><h3 id="重要思想："><a href="#重要思想：" class="headerlink" title="重要思想："></a>重要思想：</h3><p>二分、逆向思维<br><!--stackedit_data:eyJoaXN0b3J5IjpbLTg2OTgyMzE1XX0=--></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AHOI2017初中组 guide</title>
      <link href="/2018/10/23/%5BAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84%5Dguide/"/>
      <url>/2018/10/23/%5BAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84%5Dguide/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>对于一张有向图,每条边有两个边权,有两套GPS会分别按两个边权计算所在到终点的最短路,如果你不按其中一套GPS说的路走,就会产生1的抱怨,求从起点到终点的最少抱怨数</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>因为每次两套GPS都会判断当前要去的点是否在当前点到终点的最短路上,所以我们可以反向建边,跑出每套GPS从终点到每个点的最短路,然后我们重新建图,依次枚举原图的每条边,将边权赋值为2,如果要去的点在某套GPS的最短路上,边权减一.最后跑一遍最短路就可以得出$ans$</p></blockquote><ul><li>反向建边</li><li>反向SPFA</li><li>边重构</li><li>反向SPFA</li><li>$ans$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1e5+10;int n,m,head[maxn],num;int dis[maxn],dis1[maxn],di[maxn];bool use[maxn];struct fy{int from,to,d,dd,e,next;}q[maxn*5];void add(int a,int b,int c,int d){    q[++num]=(fy){a,b,c,d,0,head[a]};head[a]=num;}void sp(){    memset(dis,0x3f,sizeof dis);dis[n]=0;    memset(dis1,0x3f,sizeof dis1);dis1[n]=0;    queue&lt;int&gt;qq;qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis[b]&gt;dis[a]+q[i].d)            {                dis[b]=dis[a]+q[i].d;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }    qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis1[b]&gt;dis1[a]+q[i].dd)            {                dis1[b]=dis1[a]+q[i].dd;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}void sp1(){    memset(di,0x3f,sizeof di);di[n]=0;    queue&lt;int&gt;qq;qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(di[b]&gt;di[a]+q[i].e)            {                di[b]=di[a]+q[i].e;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b,c,d;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);        add(b,a,c,d);    }    sp();//反向SPFA    for(int i=1;i&lt;=num;i++)//边重构    {        d=2;a=q[i].from;b=q[i].to;        if(dis[b]==dis[a]+q[i].d)d--;        if(dis1[b]==dis1[a]+q[i].dd)d--;        q[i].e=d;    }    sp1();    printf(&quot;%d\n&quot;,di[1]);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTM3NTA2Nzg0NV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>军训队列</title>
      <link href="/2018/10/23/%E5%86%9B%E8%AE%AD%E9%98%9F%E5%88%97/"/>
      <url>/2018/10/23/%E5%86%9B%E8%AE%AD%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h2 id="gt-有-n-名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方-现在要将-n-名参加军训的学生分成-k-个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？"><a href="#gt-有-n-名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方-现在要将-n-名参加军训的学生分成-k-个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？" class="headerlink" title="&gt;有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方.现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？"></a>&gt;有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方.现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？</h2><ul><li>排序</li><li>DP</li></ul><blockquote><p><strong>先将身高排序,问题就转换成将一个区间切成$k$段,求$k$个区间的极值差平方和的最小值<br>对于每一个人,他的决策无非两种,加到上一个区间,或者自立门户,状态转移方程:</strong></p><ol><li><strong>加入上一个区间:</strong> &nbsp;&nbsp;$f[i][j][k]=min(f[i-1][j][k]-v[j][i-1]+v[j][i])$</li><li><strong>自立门户:</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f[i][i][k]=min(f[i-1][j][k-1])$</li></ol><p><strong>我们可以$n^2$预处理出v数组,时间复杂度为$(o)n^3$<br>但问题又来了,空间复杂度是$n^3+n^2$,可能开不下<br>我们观察到$i$维每次有用的状态只有两位,我们可以用一个滚动数组优化空间,空间复杂度变为$3\times n^2$</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=510;int n,m,h[maxn],cnt;int f[2][maxn][maxn];int v[maxn][maxn];int main(){    freopen(&quot;queue.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;queue.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;h[i]);    if(n==m)    {        printf(&quot;0\n&quot;);        return 0;    }    sort(h+1,h+1+n);memset(f,0x3f,sizeof f);    for(int i=1;i&lt;=n;i++)for(int j=i;j&lt;=n;j++)    v[i][j]=(h[j]-h[i])*(h[j]-h[i]);    f[0][0][0]=0;    for(int i=1;i&lt;=n;i++)    {        cnt^=1;memset(f[cnt],0x3f,sizeof f[cnt]);        for(int j=0;j&lt;i;j++)        {            for(int k=1;k&lt;=m;k++)            {                f[cnt][i][k]=min(f[cnt][i][k],f[cnt^1][j][k-1]);                f[cnt][j][k]=min(f[cnt][j][k],f[cnt^1][j][k]-v[j][i-1]+v[j][i]);            }        }    }    int ans=1e9+7;    for(int i=1;i&lt;=n;i++)    ans=min(ans,f[cnt][i][m]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTU3MjAzNjcwMV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元旦晚会</title>
      <link href="/2018/10/23/%E5%85%83%E6%97%A6%E6%99%9A%E4%BC%9A/"/>
      <url>/2018/10/23/%E5%85%83%E6%97%A6%E6%99%9A%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1986" target="_blank" rel="noopener"><strong>P1986</strong>  元旦晚会</a></p></blockquote><ul><li>差分约束</li><li>最长路</li></ul><p>差分裸题</p><blockquote><ol><li>dis[i]&gt;=dis[i-1]</li><li>dis[i]-dis[i-1]&lt;=1</li><li>dis[b]-dis[a-1]&gt;=c</li></ol></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3e4+10,inf=-1e9;int n,m,head[maxn],num,root,dis[maxn];bool use[maxn];struct fy{int from,to,d,next;}q[maxn&lt;&lt;2];void add(int a,int b,int c){q[++num]=(fy){a,b,c,head[a]};head[a]=num;}void sp(){    for(int i=1;i&lt;=n;i++)dis[i]=inf;dis[root]=0;    queue&lt;int&gt;qq;qq.push(root);use[root]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis[b]&lt;dis[a]+q[i].d)            {                dis[b]=dis[a]+q[i].d;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b,c;    root=maxn;int out=0;    for(int i=1;i&lt;=n;i++)    {        add(i,i-1,-1);        add(i-1,i,0);    }    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        root=min(a-1,root);        out=max(out,b);        add(a-1,b,c);    }    sp();    printf(&quot;%d\n&quot;,dis[out]);    return 0;}</code></pre><p>差分约束算是非常复杂的方法<br>这题其实可以用贪心来做(区间选点模型)<br><!--stackedit_data:eyJoaXN0b3J5IjpbLTY3NTU2OTYzNl19--></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分约束 </tag>
            
            <tag> 最长路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分块</title>
      <link href="/2018/10/23/%E5%88%86%E5%9D%97/"/>
      <url>/2018/10/23/%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>$n$个格子，现在要把它分成若干段相邻的块，要求每块不超过$m$个格子。块数不限。求分法总数对$Q$取模的结果。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>首先想到$n^2$ 的做法,我们定义$f[i]$表示划分到$i$时的合法方案的数量,不难想到转移方程:<script type="math/tex">f[i]= \sum_{j=max(0,i-m)}^{i-1}f[j]</script><br>复杂度是$(0)n^2$<br>然而数据范围是$10^6$,我们需要继续优化;<br>观察转移方程我们发现$f[i]$实际上等于一段连续区间的和,我们可以用前缀和来优化DP,这样时间复杂度就降到了$(o)n$,这道题就解决了</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1e6+10;int t,n,m,mod;ll f[maxn],s[maxn];int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;mod);        memset(f,0,sizeof f);        f[0]=1;s[0]=1;        for(int i=1;i&lt;=n;i++)        {            if(!(i-m))f[i]=s[i-1];            else f[i]=(s[i-1]-s[i-m-1])%mod;//记得取模            s[i]=(s[i-1]+f[i]);//            for(int j=max(0,i-m);j&lt;i;j++)//            f[i]+=f[j];        }        printf(&quot;%lld\n&quot;,f[n]);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTM0ODY2MjYwNV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POI working up</title>
      <link href="/2018/10/23/%5BPOI%5Dworking%20up/"/>
      <url>/2018/10/23/%5BPOI%5Dworking%20up/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有两个人和一个$n \times m$的矩阵,一个从左上角出发,只能向右,向下走,去右下角;另一个从右上角出发只能向左,向下走,去左下角.矩阵的每一格有一个权值,走过会得到这个权值.很显然,两个人肯定会相遇,他们相遇的那一格的权值不取,求两人只相遇一次权值和的最大值</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>读完题,你是否有想到<code>方格取数</code><br>做法非常简单也非常暴力,开四个二维数组分别记录从四个角出发的最优解,然后$n^2$枚举合法的点,更新$ans$<br>因为只相遇一次,所以两人相遇时只有两种直线走法,不会转弯</strong></p><ul><li>注意下标,容易迷糊</li><li>记得开<code>long long</code><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding:"></a>Coding:</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1010;ll mp[maxn][maxn],f1[maxn][maxn];ll f2[maxn][maxn],f3[maxn][maxn];ll f4[maxn][maxn];int n,m;int main(){  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%lld&quot;,&amp;mp[i][j]);  for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)  f1[i][j]=max(f1[i-1][j],f1[i][j-1])+mp[i][j];  for(int i=n;i;i--)for(int j=m;j;j--)  f2[i][j]=max(f2[i+1][j],f2[i][j+1])+mp[i][j];  for(int i=1;i&lt;=n;i++)for(int j=m;j;j--)  f3[i][j]=max(f3[i-1][j],f3[i][j+1])+mp[i][j];  for(int i=n;i;i--)for(int j=1;j&lt;=m;j++)  f4[i][j]=max(f4[i+1][j],f4[i][j-1])+mp[i][j];  //暴力美学  ll ans=0;  for(int i=2;i&lt;n;i++)for(int j=2;j&lt;m;j++)  {      ans=max(ans,f1[i][j-1]+f2[i][j+1]+f3[i-1][j]+f4[i+1][j]);      ans=max(ans,f1[i-1][j]+f2[i+1][j]+f3[i][j+1]+f4[i][j-1]);  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMjAxNTEzOTAxMiwtMjExMjg0OTMyMCw4MzExMjc2MzhdfQ==--></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>割点和桥学习</title>
      <link href="/2018/10/23/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%20%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/23/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%20%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><p>说实话,tarjan是个好东西<br>然而我却丢了他的脸<br>到现在我还是很迷糊</p><ul><li>注意缩点,割点和割边的不同</li><li>这东西有毒,剧毒<del>mmp</del></li><li>割点</li><li>割边<ul><li>当存在重边时应将记录父亲节点改为记录父亲边</li></ul></li><li>点双联通分量</li><li>边双联通分量<ul><li>可在求割边时同时求出</li></ul></li><li>tarjan</li></ul><pre><code class="lang-cpp">//割边 &amp;&amp; 没有重边#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5e3+10;int n,m,head[maxn],num;int dfn[maxn],low[maxn],input;bool use[maxn];struct fy{int to,next;}q[maxn&lt;&lt;2];void add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}void tar(int a,int fa){    dfn[a]=low[a]=++input;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(!dfn[b])        {            tar(b,a);low[a]=min(low[a],low[b]);            if(dfn[a]&lt;low[b])use[i]=true;//感觉这个地方这辈子都不会懂了,太迷幻            //当然可以和割点一起求            /*if((child&gt;1&amp;&amp;root==a)||(root!=a&amp;&amp;dfn[a]&lt;=low[b])cutd[i]=true;*/            //root为根节点        }        else if(b!=fa)low[a]=min(low[a],dfn[b]);        //为什么是b!=fa呢,不懂    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);    }    for(int i=1;i&lt;=n;i++)if(!dfn[i])tar(i,0);    for(int i=1;i&lt;=num;i++)if(use[i])printf(&quot;%d &quot;,i);    return 0;}</code></pre><p>当有重边时记录父亲<strong>边</strong></p><pre><code class="lang-cpp">//割边&amp;&amp;边双缩点&amp;&amp;有重边&amp;&amp;非边双转边双#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5e3+10;int n,m,head[maxn],num,bi,cnt,ans,fa[maxn],in[maxn];bool use[maxn&lt;&lt;2];int dfn[maxn],low[maxn],input,xx[maxn],w,pa[maxn];struct fy{int from,to,next,h;}q[maxn&lt;&lt;2];//h用来装边void add(int a,int b){    q[++num]=(fy){a,b,head[a],++bi};head[a]=num;    q[++num]=(fy){b,a,head[b],bi};head[b]=num;}void tar(int a){    dfn[a]=low[a]=++input;xx[++w]=a;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(q[i].h==pa[a])continue;//如果该边走过了就不能再走        if(!dfn[b])        {            pa[b]=q[i].h;//记录父亲边            tar(b);low[a]=min(low[a],low[b]);        }        else low[a]=min(low[a],dfn[b]);    }    if(dfn[a]==low[a])//同时边双缩点    {        cnt++;        while(xx[w+1]!=a)        {fa[xx[w]]=cnt;w--;}    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);    }    tar(1);    for(int i=1;i&lt;=num;i++)    {        a=fa[q[i].from];        b=fa[q[i].to];        if(a!=b)in[b]++;    }    for(int i=1;i&lt;=cnt;i++)if(in[i]==1)ans++;    printf(&quot;%d\n&quot;,(ans+1)/2);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTExMjM0NDMxMTFdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 割点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷油漆</title>
      <link href="/2018/10/23/%E5%88%B7%E6%B2%B9%E6%BC%86/"/>
      <url>/2018/10/23/%E5%88%B7%E6%B2%B9%E6%BC%86/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>cxm 需要给一块长木板刷上油漆。他一次可以将一段的木板刷上同一种颜色，刷过的木板可以再刷成其他颜色。现在木板被分成了若干块，每块需要涂成一个确定的颜色。 cxm 希望你告诉他最少需要涂几次就可以将每块都涂成需要的颜色。</p></blockquote><ul><li>区间DP</li><li>$turn$函数比较迷</li><li>有十分有毒~(学长有毒)~</li></ul><p>还是比较简单的区间DP,就是在区间DP基础上加了一个$turn$<br>虽然我没搞懂$turn$<del>(但我拿了90,滑稽)</del></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2010;int n,t,s[maxn];int f[maxn][maxn];int turn(int a,int b,int c){    if(s[a]==s[b]||s[a]==s[c+1]||s[c]==s[b]||s[c]==s[c+1])return -1;    return 0;}int main(){    freopen(&quot;paint.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;paint.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(f,0x3f,sizeof f);        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {             scanf(&quot;%d&quot;,&amp;s[i]);             f[i][i]=1;        }        for(int l=1;l&lt;=n;l++)for(int i=1;i+l&lt;=n;i++)        {             int j=i+l;for(int k=i;k&lt;j;k++)             f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+turn(i,j,k));        }        printf(&quot;%d\n&quot;,f[1][n]);    }}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbODkxMjY4MjZdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串的最小表示</title>
      <link href="/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/"/>
      <url>/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>开两个指针,依次对比;<br>当第二个指针比第一个更优时,更新第一个指针为第二个指针,第二个指针+1</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=3e5+10;int n;char str[maxn];int l,w;int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        scanf(&quot;%d%s&quot;,&amp;l,str);        for(int i=0;i&lt;l;i++)        str[i+l]=str[i];        int ll=0,rr=1;        while(ll&lt;l&amp;&amp;rr&lt;l)        {            int i=0;            while(str[ll+i]==str[rr+i]) i++;            if(i&gt;=l) break;            if(str[ll+i]&gt;str[rr+i])             {                if(ll+i+1&gt;rr) ll=ll+i+1;                else ll=rr+1;            }            else if(rr+1+i&gt;ll) rr=rr+i+1;            else rr=ll+1;        }        printf(&quot;%d\n&quot;,min(ll,rr));    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTc0ODczOTE1MF19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 最小表示法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排队接水</title>
      <link href="/2018/10/23/%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4/"/>
      <url>/2018/10/23/%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>   现在一个水龙头前面有 n 个人需要接水，他们的编号为 1 到 n 的整数。他们每个人有各自接水需要花费的时间，其中编号为 i 的人花费的时间为 Ti。另外每个人有各自的紧急程度，编号为 i 的人紧急程度为 Ei。现在我们需要给所有人排出一个序，使得总不和谐程度最低。我们定义一个人的等待时间为排在他前面的人和这个人花费的时间之和，一个人的不和谐程度为这个人的等待时间乘以这个人的紧急程度，总不和谐程度为所有人的<br>不和谐程度的和。<br>即我们需要求出一个 1 到 n 的排列 faig ，使得 $\sum_{i=1}^n( \sum^n _{j=1} T_{a_j} )$ 最小。</p></blockquote><ul><li>贪心 </li><li>然后没了</li><li>类似<code>国王游戏</code></li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=2e5+10;int n,t;ll ans,s;struct fy{    int t,v;double s;    void w(){this-&gt;s=(double)this-&gt;t/(double)this-&gt;v;}    bool operator&lt;(const fy&amp;a)    const{return s&lt;a.s;}}q[maxn];int read(){     int k=0,f=0;char c=getchar();for(;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;;c=getchar())if(c==&#39;-&#39;)f=1;     for(;c&lt;=&#39;9&#39;&amp;&amp;c&gt;=&#39;0&#39;;c=getchar())k=(k&lt;&lt;3)+(k&lt;&lt;1)+c-&#39;0&#39;;return  f?-k:k;}int main(){     freopen(&quot;water.in&quot;,&quot;r&quot;,stdin);     freopen(&quot;water.out&quot;,&quot;w&quot;,stdout);     t=read();     while(t--)     {         n=read();ans=0;s=0;         for(int i=1;i&lt;=n;i++)         {q[i].t=read();q[i].v=read();q[i].w();}         sort(q+1,q+1+n);         for(int i=1;i&lt;=n;i++)         {             s+=q[i].t;             ans+=(ll)s*(ll)q[i].v;        }        printf(&quot;%lld\n&quot;,ans);    }     return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTU3NjI5NTQ0Nl19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Picnic Planning</title>
      <link href="/2018/10/23/Picnic%20Planning/"/>
      <url>/2018/10/23/Picnic%20Planning/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>矮人虽小却喜欢乘坐巨大的轿车，车大到能够装下不管多少矮人。某天，N(N≤20)个矮人打算到野外聚餐。为了集中到聚餐地点，矮人A 要么开车到矮人B 家中，留下自己的轿车在矮人B 家，然后乘坐B 的轿车同行；要么直接开车到聚餐地点，并将车停放在聚餐地。尽管矮人的家非常大，能够停放无数量轿车，可是聚餐地点却最多仅仅能停放K 辆轿车。给你一张加权无向图，描写叙述了N 个矮人的家和聚餐地点，求出全部矮人开车最短总路程</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>题本身是一道$k$限制生成树裸题,但那东西太迷幻,不会.因为数据规模比较小,暴力能过,所以也没学.这里用的是状压$+Prim$.</strong><br><strong>因为根节点只能连不大于$k$条边,所以我们暴力枚举根节点能连的边的状态,再将剩下的点跑最小生成树,更新最小代价.</strong></p></blockquote><ul><li>用$map$映射每个人的名字</li><li>可能有重边,需要更新两点之间的最短距离</li><li>这里我们用邻接矩阵存边,用$Prim$跑最小生成树,不然时间复杂度过不去</li><li>每次生成树必须加够$N-1$条边后才能更新$ans$</li><li>输出应遵循题目规则</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=430;int n,k,num,cnt;int fa[22],ans,bns;map&lt; string , int &gt;mm;int ss[22][22];struct fy{    int from,to,d;    bool operator&lt;(const fy&amp;a)const{return d&lt;a.d;};}q[maxn];char str[30],str1[30];void add(int a,int b,int c){q[++num]=(fy){a,b,c};}int can(int a){    bns=0;    int he=0,w=1;    while(a)    {        ++w;        if(a&amp;1)        {            he++;fa[w]=1;            if(ss[1][w]==ss[0][0])return 0;            bns+=ss[1][w];        }        a&gt;&gt;=1;    }    if(he&lt;=k)return he;    return 0;}int find(int a){    while(a!=fa[a])a=fa[a]=fa[fa[a]];    return a;}void ku(int x)//披着羊皮的狼(滑稽){    if(!x)return;    for(int i=1;i&lt;=num;i++)    {        if(q[i].from==1||q[i].to==1)continue;        int a=find(q[i].from);        int b=find(q[i].to);        if(a!=b)        {            if(x==(cnt-1))break;            fa[a]=b;            x++;            bns+=q[i].d;            if(bns&gt;ans)return;        }    }    if(x==(cnt-1))ans=min(ans,bns);}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        mm.clear();cnt=0;num=0;        scanf(&quot;%d&quot;,&amp;n);memset(ss,0x3f,sizeof ss);        mm[&quot;Park&quot;]=++cnt;ans=ss[0][0];        for(int i=1;i&lt;=n;i++)        {            int a,b,c;            scanf(&quot;%s%s%d&quot;,str,str1,&amp;c);            if(!mm[str])mm[str]=++cnt;            if(!mm[str1])mm[str1]=++cnt;            a=mm[str];b=mm[str1];            ss[a][b]=min(ss[a][b],c);            ss[b][a]=ss[a][b];        }        scanf(&quot;%d&quot;,&amp;k);        for(int i=1;i&lt;=cnt;i++)for(int j=i+1;j&lt;=cnt;j++)        if(ss[i][j]&amp;&amp;(ss[i][j]!=ss[0][0]))add(i,j,ss[i][j]);        sort(q+1,q+1+num);        for(int s=0;s&lt;(1&lt;&lt;(cnt-1));s++)//枚举根节点的状态        {            for(int i=1;i&lt;=cnt;i++)fa[i]=i;            ku(can(s));        }        printf(&quot;Total miles driven: %d\n&quot;,ans);//输出    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTIwNTg2NDcyMTddfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成树 </tag>
            
            <tag> 状压 </tag>
            
            <tag> K限制生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「一本通 1.1 例 5」智力大冲浪</title>
      <link href="/2018/10/23/%E6%99%BA%E5%8A%9B%E6%8C%91%E6%88%98/"/>
      <url>/2018/10/23/%E6%99%BA%E5%8A%9B%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><ul><li>带限期和罚款的单位时间任务调度<ul><li>按期限排序<ul><li>用优先队列维护</li><li>若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队</li><li>若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队</li><li>最后累加队列中的元素权值,$v$减去这个和即为答案</li></ul></li></ul></li></ul></blockquote><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding:"></a>Coding:</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+10;int n,l,v,ans;struct fy{    int x,y;    bool operator&lt;(const fy&amp;a)    const{return x&lt;a.x;};}q[maxn];struct ffy{    int x;    bool operator&lt;(const ffy&amp;a)    const{return x&gt;a.x;}};priority_queue&lt;ffy&gt;qq;int main(){    scanf(&quot;%d%d&quot;,&amp;v,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;q[i].x);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;q[i].y);        ans+=q[i].y;    }    sort(q+1,q+1+n);    for(int i=1;i&lt;=n;i++)    {        int a=q[i].x;        int b=q[i].y;        if(l&lt;a)        {            qq.push((ffy){b});            l++;        }        else         {            int c=qq.top().x;            if(b&gt;c)            {                qq.pop();                qq.push((ffy){b});            }        }    }    while(!qq.empty())    {        ans-=qq.top().x;        qq.pop();    }    printf(&quot;%d\n&quot;,v-ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 一本通 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>核电站问题</title>
      <link href="/2018/10/23/%E6%A0%B8%E7%94%B5%E7%AB%99%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/23/%E6%A0%B8%E7%94%B5%E7%AB%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续M个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质.现在，请你计算：对于给定的N和M，求不发生爆炸的放置核物质的方案总数。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>很简单的一道DP,我们定义$F[i][j]$表示第$i$个坑已经连续装了$j$个核物质,那么状态无外乎两种:</strong> </p><ol><li>下一个坑继续装</li><li>下一个坑不装</li></ol><p><strong>答案就是$\sum_{i=0}^mF[n][i]$</strong></p></blockquote><ul><li>当连续放$m$个坑的时候,就会发生爆炸,所以$m$应该减一</li><li>初始条件是$F[0][0]=1$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=110;int n,m;ll f[maxn][10];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    f[0][0]=1;m--;    for(int i=1;i&lt;=n;i++)    {        for(int j=0;j&lt;=m;j++)        f[i][0]+=f[i-1][j];        for(int j=1;j&lt;=m;j++)        f[i][j]+=f[i-1][j-1];    }    ll ans=0;    for(int i=0;i&lt;=m;i++)ans+=f[n][i];    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTEwMDIyMjk0M119-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> vijos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>摆花</title>
      <link href="/2018/10/23/%E6%91%86%E8%8A%B1/"/>
      <url>/2018/10/23/%E6%91%86%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有$n$种花,每种有$a_i$盆,要摆$m$盆,每种花连续并且编号大的在后.求有多少种摆法</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>一道简单的计数DP.<br>我们定义$f[i][j]$表示放第$i$种花时一共放了$j$盆时的方案数,那么状态转移方程:</strong><script type="math/tex">f[i][j]=\sum_{k=0}^{a[i]} f[i-1][j-k]</script></p></blockquote><ul><li>$f[0][0]=1$</li><li>$j&gt;=k$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110,mod=1e6+7;int n,m,f[maxn][maxn],a[maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[0][0]=1;    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)    for(int j=0;j&lt;=m;j++)    for(int k=0;k&lt;=a[i];k++)if(j&gt;=k)    f[i][j]=(f[i][j]+f[i-1][j-k])%mod;    printf(&quot;%d\n&quot;,f[n][m]);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTI1NjgwMDk5OF19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HDU warm up</title>
      <link href="/2018/10/23/HDU%20warm%20up/"/>
      <url>/2018/10/23/HDU%20warm%20up/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有一张联通的无向图,再加一条无向边后最少的桥的数量</p></blockquote><ul><li>求桥时将边双缩点,记录桥数 <strong>ans</strong></li><li>建树,求最长路长度 <strong>bns</strong></li><li>答案为 <strong>ans-bns</strong> </li><li>多组数据,注意初始化</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e5+10,maxm=1e6+10;int n,m,head[maxn],num,cnt,bi,ans;int dfn[maxn],low[maxn],input,fa[maxn],pa[maxn];int xx[maxn],w,headd[maxn],numm,mdep,ww;struct fy{int from,to,next,h;}q[maxm&lt;&lt;1];struct ffy{int to,next;}qq[maxm&lt;&lt;1];void add(int a,int b){    q[++num]=(fy){a,b,head[a],++bi};head[a]=num;    q[++num]=(fy){b,a,head[b],bi};head[b]=num;}void addd(int a,int b){qq[++numm]=(ffy){b,headd[a]};headd[a]=numm;}void tar(int a){    dfn[a]=low[a]=++input;xx[++w]=a;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;if(q[i].h==pa[a])continue;        if(!dfn[b])        {            pa[b]=q[i].h;tar(b);            low[a]=min(low[a],low[b]);            if(dfn[a]&lt;low[b])ans++;        }        else low[a]=min(low[a],dfn[b]);    }    if(low[a]==dfn[a])    {        ++cnt;        while(xx[w+1]!=a)        {            fa[xx[w]]=cnt;            w--;        }    }}void dfs(int a,int fat,int dep){    if(dep&gt;mdep)    {        mdep=dep;        ww=a;    }    for(int i=headd[a];i;i=qq[i].next)    {        int b=qq[i].to;if(b==fat)continue;        dfs(b,a,dep+1);    }}int main(){    int a,b;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)    {        if(n==0&amp;&amp;m==0)break;        memset(head,0,sizeof head);memset(dfn,0,sizeof dfn);        memset(low,0,sizeof low);memset(pa,0,sizeof pa);        memset(headd,0,sizeof headd);        num=0;cnt=0;bi=0;w=0;input=0;numm=0;ans=0;ww=0;        for(int i=1;i&lt;=m;i++)        {scanf(&quot;%d%d&quot;,&amp;a,&amp;b);add(a,b);}        tar(1);        for(int i=1;i&lt;=num;i++)        {            a=fa[q[i].from];b=fa[q[i].to];            if(a!=b)addd(a,b);        }        mdep=0;dfs(1,0,0);        mdep=0;dfs(ww,0,0);        printf(&quot;%d\n&quot;,ans-mdep);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE1OTc1ODc0MDddfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥 </tag>
            
            <tag> 边双联通分量 </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>烽火传递</title>
      <link href="/2018/10/23/%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92/"/>
      <url>/2018/10/23/%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>在某两座城市之间有 n 个烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确的传递，在任意相邻的 m 个烽火台中至少要有一个发出信号。现在需要计算总共最少需要花费多少代价，才能使敌军来袭之时，情报能在这两座城市之间准确的传递。</p><ul><li>单调队列优化 <pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10,inf=1e9+7;int n,t,m,f[maxn][2],v[maxn];int q[maxn&lt;&lt;1],p[maxn&lt;&lt;1];int main(){  freopen(&quot;flame.in&quot;,&quot;r&quot;,stdin);  freopen(&quot;flame.out&quot;,&quot;w&quot;,stdout);  scanf(&quot;%d&quot;,&amp;t);  while(t--)  {      scanf(&quot;%d%d&quot;,&amp;n,&amp;m);      for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);       int t=0,h=1;      for(int i=1;i&lt;=n;i++)      {           int a=0;          if(i-p[h]&gt;m)h++;          if(i&gt;m)a=v[i]+q[h];else a=v[i];          while(t&gt;=h&amp;&amp;q[t]&gt;a)t--;           q[++t]=a;p[t]=i;      }      int ans=inf;      if(n-p[h]&gt;=m)h++;      for(int i=max(h,t-m+1);i&lt;=t;i++)      ans=min(ans,q[i]);      printf(&quot;%d\n&quot;,ans);  }  return 0;}</code></pre></li></ul><hr><p>可以加一位n+1,直接作为ans,省去后面的ans统计<br><br>可以省去一些麻烦(<del>比如3个小时</del>)</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10,inf=1e9+7;int n,t,m,f[maxn][2],v[maxn];int q[maxn&lt;&lt;1],p[maxn&lt;&lt;1];int main(){    freopen(&quot;flame.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;flame.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);         int t=0,h=1;        for(int i=1;i&lt;=n+1;i++)//n+1        {             int a=0;            if(i-p[h]&gt;m)h++;            if(i&gt;m)a=v[i]+q[h];else a=v[i];            while(t&gt;=h&amp;&amp;q[t]&gt;a)t--;             q[++t]=a;p[t]=i;        }        printf(&quot;%d\n&quot;,q[t]);//直接输出    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE3MDU4NzM2OThdfQ==--></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列优化DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>灯泡</title>
      <link href="/2018/10/23/%E7%81%AF%E6%B3%A1/"/>
      <url>/2018/10/23/%E7%81%AF%E6%B3%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>求$L$最大值</p></blockquote><p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=light_bulb_1037_ddd01.gif" alt="asdfasdf"></p><blockquote><p><strong>我们设人与灯低的距离为$x$,墙上的部分长$y$,用$x$表示出$L$和$y$,通过均值不等式求解最大值</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int t;double H,h,D;double cal(){    double x=sqrt((H-h)*D);//均值不等式成立条件    x=min(x,D);//x右边界    x=max(x,(D*H-D*h)/H);//x左边界    return D+H-x-(H-h)*D/x;}int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lf%lf%lf&quot;,&amp;H,&amp;h,&amp;D);        printf(&quot;%.3lf\n&quot;,cal());    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE5MTM4MzgyMThdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 均值不等式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>球和盒子问题</title>
      <link href="/2018/10/23/%E7%90%83%E5%92%8C%E7%9B%92%E5%AD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/23/%E7%90%83%E5%92%8C%E7%9B%92%E5%AD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://s1.ax1x.com/2018/10/12/itXzw9.jpg" alt=""></p><ul><li>$F[i][j]=F[i-1][j-1]+j*F[i-1]<a href="F[1][1]=1">j</a>$</li><li>$G[i][j]=G[i][j-1]+G[i-j]<a href="G[0][i]=G[1][i]=G[i][1]=1">j</a>$</li><li>注意各种情况的初始化</li></ul><h3 id="1-放苹果"><a href="#1-放苹果" class="headerlink" title="1.放苹果"></a>1.放苹果</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int t,n,m;int f[maxn][maxn];int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=0;i&lt;=10;i++)f[0][i]=f[i][1]=f[1][i]=1;    for(int i=1;i&lt;=10;i++)for(int j=2;j&lt;=10;j++)    {        f[i][j]=f[i][j-1];        if(i&gt;=j)f[i][j]+=f[i-j][j];    }    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        printf(&quot;%d\n&quot;,f[n][m]);    }    return 0;}</code></pre><h3 id="2-数的划分"><a href="#2-数的划分" class="headerlink" title="2.数的划分"></a>2.数的划分</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=210;int n,m;ll f[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n;i++)f[0][i]=f[1][i]=f[i][1]=1;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    {        f[i][j]=f[i][j-1];        if(i&gt;=j)f[i][j]+=f[i-j][j];    }    printf(&quot;%lld\n&quot;,f[n-m][m]);    return 0;}</code></pre><h3 id="6-小朋友的球"><a href="#6-小朋友的球" class="headerlink" title="6.小朋友的球"></a>6.小朋友的球</h3><pre><code class="lang-cpp">//这题要高精#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=110;int n,m;ll f[maxn][maxn];int main(){    f[1][1]=1;    for(int i=2;i&lt;=100;i++)for(int j=1;j&lt;=100;j++)    f[i][j]=f[i-1][j-1]+f[i-1][j]*j;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)    {        printf(&quot;%lld\n&quot;,f[n][m]);    }    return 0;}</code></pre><h3 id="8-盒子和小球"><a href="#8-盒子和小球" class="headerlink" title="8.盒子和小球"></a>8.盒子和小球</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int n,m,f[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[1][1]=m;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    f[i][j]=f[i-1][j-1]*(m-j+1)+f[i-1][j]*j;    printf(&quot;%d\n&quot;,f[n][m]);    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int n,m,f[maxn][maxn];int work(int a){    int ans=1;    for(int i=2;i&lt;=a;i++)    ans*=i;    return ans;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[1][1]=1;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    f[i][j]=f[i-1][j-1]+f[i-1][j]*j;    printf(&quot;%d\n&quot;,f[n][m]*work(m));    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTA3ODk0NTYwNCwxNjc5NzYzNDE0XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数DP </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>过河</title>
      <link href="/2018/10/23/%E8%BF%87%E6%B2%B3/"/>
      <url>/2018/10/23/%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1052" target="_blank" rel="noopener"><strong>P1052</strong>  过河</a></p></blockquote><ul><li>排序</li><li>离散化</li><li>DP</li></ul><blockquote><p><strong>桥很长,不能直接DP;而石子数比较少,这时我们想到离散化;<br>当两点间的距离$d$大于$t$时,一定可以由d%t跳过来,所以最多只需要t+d%t种距离的状态就可以表示这两个石子之间的任意距离关系.这样就把题目中的$10^9$压缩成了$2\times t\times m$最多不超过$2000$,然后就可以放心大胆地用DP了.不过要注意题目中的”当青蛙跳到或跳过坐标为L的点时.就算青蛙已经跳出了独木桥”,所以DP的终点是一个范围而非确切的一个点，最后还要在这个范围内取最小值。</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=2e3+10;int l,s,t,m,n;int f[maxn],lo[200];bool use[maxn];int main(){    scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;s,&amp;t,&amp;m);    memset(f,0x3f,sizeof f);f[0]=0;    for(int i=1;i&lt;=m;i++)scanf(&quot;%d&quot;,&amp;lo[i]);    sort(lo+1,lo+1+m);    for(int i=1;i&lt;=m;i++)    {        if(lo[i]-lo[i-1]&gt;=t)n+=(lo[i]-lo[i-1])%t+t;        else n+=(lo[i]-lo[i-1]);        use[n]=true;    }    n+=(l-lo[m])%t;    for(int i=1;i&lt;=n+t-1;i++)    {        for(int j=s;j&lt;=t;j++)if(i-j&gt;=0)        f[i]=min(f[i],f[i-j]);        if(use[i])f[i]++;    }    int ans=1e9;    for(int i=n;i&lt;=n+t-1;i++)ans=min(ans,f[i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMjIyNTQyMTM3XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>钓鱼</title>
      <link href="/2018/10/23/%E9%92%93%E9%B1%BC/"/>
      <url>/2018/10/23/%E9%92%93%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>一条路上有$N$个鱼塘,鱼塘$i$花5$min$可以钓$t_i$条鱼,但每钓一次能钓到的鱼数量会减去$s_i$,并且从鱼塘$i$走到鱼塘$i+1$会花费$5\times dis_i$的时间.现在有$H$小时的时间,可以在任意鱼塘结束,求最多能钓多少条鱼</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>非常巧妙的一道贪心题.<br>我们枚举结束的鱼塘,用总时间减去路上花掉的时间,剩下的时间用来钓鱼.<br>先将路上经过的鱼塘第一个5$min$能钓到的鱼条数加入优先队列,每次取出队列中最大元素的加入该鱼塘的答案,将该元素减去对应的$s_i$加入队列,直到时间用尽或者优先队列中最大值小于等于0,更新答案</strong></p></blockquote><ul><li>注意时间的转化</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110;int n,h,dis[maxn],ans,bns;int s[maxn],ss[maxn];struct ffy{    int x,y;    bool operator&lt;(const ffy&amp;a)    const{return x&lt;a.x;};};priority_queue&lt;ffy&gt;qq;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;h);h*=12;    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;ss[i]);    for(int i=2;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;dis[i]);    for(int i=1;i&lt;=n;i++)    {        h-=dis[i];int time=0;bns=0;        for(int j=1;j&lt;=i;j++)qq.push((ffy){s[j],j});        while(++time&lt;=h&amp;&amp;!qq.empty())        {            int a=qq.top().x;            int b=qq.top().y;            if(a&lt;=0)break;            bns+=a;            qq.pop();            qq.push((ffy){a-ss[b],b});        }        ans=max(ans,bns);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMzYyNzgzMzY1XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心五种常见模型</title>
      <link href="/2018/10/23/%E8%B4%AA%E5%BF%83%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/23/%E8%B4%AA%E5%BF%83%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-区间不相交问题"><a href="#1-区间不相交问题" class="headerlink" title="1. 区间不相交问题"></a>1. 区间不相交问题</h3><blockquote><ul><li>按右端点排序</li><li>枚举,当左端点未被标记时,$ans++$,标记右端点 </li></ul><hr><h3 id="2-区间选点问题"><a href="#2-区间选点问题" class="headerlink" title="2. 区间选点问题"></a>2. 区间选点问题</h3><ul><li>按右端点排序</li><li>枚举,当该区间未被选够点时,从后往前选择未被选择的点,直到选够</li></ul><hr><h3 id="3-区间覆盖问题"><a href="#3-区间覆盖问题" class="headerlink" title="3. 区间覆盖问题"></a>3. 区间覆盖问题</h3><ul><li>按左端点排序</li><li>枚举,选择能覆盖当前节点,右端点最远的节点,将当前节点更新为该最远节点的右端点</li></ul><hr><h3 id="4-流水作业调度问题"><a href="#4-流水作业调度问题" class="headerlink" title="4. 流水作业调度问题"></a>4. 流水作业调度问题</h3><ul><li>Johnson算法(<del>比较迷,反正我没懂</del>)</li><li>按$min(i.a,j.b)&lt;min(i.b,j.a)$排序</li><li>枚举记录$ans$</li></ul><hr><h3 id="5-带限期和罚款的单位时间任务调度"><a href="#5-带限期和罚款的单位时间任务调度" class="headerlink" title="5. 带限期和罚款的单位时间任务调度"></a>5. 带限期和罚款的单位时间任务调度</h3><ul><li>按期限排序</li><li>用优先队列维护</li><li>若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队</li><li>若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队</li><li>最后累加队列中的元素权值</li></ul></blockquote><!--stackedit_data:eyJoaXN0b3J5IjpbMjA5OTg2OTc5NV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>铺地板</title>
      <link href="/2018/10/23/%E9%93%BA%E5%9C%B0%E6%9D%BF/"/>
      <url>/2018/10/23/%E9%93%BA%E5%9C%B0%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>NS 中学新建了一个 n × n 的正方形广场，现在需要你用 1 × 2 的地板砖去铺这个广场。由于各种原因，广场上有些地方不能铺地板（比如那里种了一棵树或者有一个井盖）。显然，地板也不能重叠放置. 现在你需要求出最少有多少个格子不能被地板铺上（包括不能铺地板的地方）。</p></blockquote><ul><li>看出二分图</li><li>然后 $AC$ ~(滑稽)~</li></ul><p>只要看出是二分图模型就非常简单<br>建双向边得出的$ans$最大匹配的二倍<br>但因为一条边连接两个点所以直接输出$n^2-ans$</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=70;int n,head[maxn*maxn],num,p[maxn*maxn];int cnt,t,map[maxn][maxn];bool use[maxn*maxn];int mx[4]={0,0,-1,1};int my[4]={1,-1,0,0};char str[maxn];struct fy{int to,next;}q[maxn*maxn*10];void add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}bool find(int a){    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(!use[b])        {            use[b]=true;            if(!p[b]||find(p[b]))            {                p[b]=a;                return true;            }        }    }    return false;}int main(){    freopen(&quot;floor.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;floor.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);memset(head,0,sizeof head);        cnt=0;num=0;memset(map,0,sizeof map);        memset(p,0,sizeof p);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,str);            for(int j=0;j&lt;n;j++)            if(str[j]==&#39;.&#39;)map[i][j+1]=++cnt;        }        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)        if(map[i][j])        {            int a=map[i][j];            for(int k=0;k&lt;4;k++)            {                int b=map[i+mx[k]][j+my[k]];                if(b)add(a,b);            }        }        int ans=0;        for(int i=1;i&lt;=cnt;i++)        {            memset(use,false,sizeof use);            if(find(i))ans++;        }        printf(&quot;%d\n&quot;,n*n-ans);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE0NTYyNTc3MzBdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>逐个击破</title>
      <link href="/2018/10/23/%E9%80%90%E4%B8%AA%E5%87%BB%E7%A0%B4/"/>
      <url>/2018/10/23/%E9%80%90%E4%B8%AA%E5%87%BB%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>现在有N个城市，其中K个被敌方军团占领了，N个城市间有N-1条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你K个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这K个地方军团互相隔离开，以便第二步逐个击破敌人。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>我们加一个辅助数组记录每个城市是否被占领,然后跑最大生成树.当且仅当两个城市所在的连通块都被占领时,我们不取这条边,其余时候将当前两个城市的占领属性合并,最后 $ans$=用总代价-最大生成树权值和</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1e5+10;int n,k,fa[maxn];ll ans;bool ee[maxn];struct fy{    int from,to,d;    bool operator&lt;(const fy&amp;a)    const{return d&gt;a.d;};}q[maxn];int find(int a){    while(a!=fa[a])a=fa[a]=fa[fa[a]];    return a;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i=1;i&lt;=k;i++)    {        int a;        scanf(&quot;%d&quot;,&amp;a);        ee[a]=true;    }    for(int i=1;i&lt;=n;i++)fa[i]=i;    for(int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;q[i].from,&amp;q[i].to,&amp;q[i].d);        ans+=q[i].d;    }    sort(q+1,q+n);    for(int i=1;i&lt;n;i++)    {        int a=find(q[i].from);        int b=find(q[i].to);        if(ee[a]&amp;&amp;ee[b])continue;        fa[a]=b;        ee[a]|=ee[b];ee[b]|=ee[a];//合并属性        ans-=q[i].d;    }     printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbNjQ2MDkzNzk2XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="居然有人点开了这个页面-ΩДΩ"><a href="#居然有人点开了这个页面-ΩДΩ" class="headerlink" title="居然有人点开了这个页面 (ΩДΩ)"></a>居然有人点开了这个页面 (ΩДΩ)</h1><p>可能是你点错了,毕竟我这么菜,<br>谁会来看我呢<del>(滑稽)</del></p><p><img src="https://s1.ax1x.com/2018/10/24/ir5US0.png" alt=""></p><p>本人一名<strong>小蒟蒻</strong>,在各位大佬间苦苦挣扎,苟且偷生<del>(宝宝心里苦,难受,香菇)</del></p><p>不喜欢打游戏(偶尔玩玩),喜欢搞一些计算机上奇奇怪怪的东西(对,就是老师和爸妈口中的”不务正业”,”没名堂的东西”,”浪费时间”)</p><p>喜欢二次元,喜欢宅在家里的穷学生</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5ITH.gif" alt="ir5ITH.gif"></p><p>学过一点点C++和Java,算法也有一点涉猎(请记住,是一点点,就像你对于地球那样的一点点),当然没有办法和各位大佬比</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5Dw4.gif" alt="ir5Dw4.gif"></p><p>还是一位OIer,虽然马上退役了,好吧,像我这种弱鸡,根本不能说退役,是根本没入役</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5yk9.jpg" alt="ir5yk9.jpg"></p><p>好吧,了解了我的菜之深后,你肯定也不想继续看下去了,但我还是厚颜无耻的写下我的联系方式</p><p>QQ: </p><blockquote><p>1836017424</p></blockquote><p>Email: </p><blockquote><p>1836017424@qq.com </p><p>scaryffy@gmail.com</p></blockquote><p>你如果有问题,可以通过上面的方式联系我(可能这辈子都不会有了)</p><p>在下学生,不能保证及时回复,但我看到了一定会回复</p><p><img src="https://s1.ax1x.com/2018/10/24/ir550e.jpg" alt="ir550e.jpg"></p><h3 id="愿幸运与你同在"><a href="#愿幸运与你同在" class="headerlink" title="愿幸运与你同在"></a>愿幸运与你同在</h3><p>但如果你有上条当麻的右手,我还真没办法</p><p>至此</p>]]></content>
      
    </entry>
    
  
</search>
