[{"title":"hexo主题推荐","url":"/2018/10/23/hexo主题推荐/","content":"弄了一周多的hexo,主题换了又换,最终还是决定用这个material主题,如果你喜欢,可以到github上的[Material](https://github.com/viosey/hexo-theme-material)下载它\n\n1.5.5的版本好像有点小问题~~(应该是我太菜)~~装了好几次都装不上,最后选择了1.5.2的版本\n\n![](https://s1.ax1x.com/2018/10/24/ir5YYn.jpg)\n\n另外几个主题也很不错\n\n[Mdui](https://github.com/Halyul/hexo-theme-mdui)\n\n> ~~(本地装起了,webide上没装起,2333)~~界面上和Material很像,但也有很多不一样的地方,很细致\n\n[Next](https://github.com/iissnan/hexo-theme-next)\n\n> 网上教程最多的hexo主题,入门十分简单~~(花了几天还真是抱歉)~~,界面比较简洁,很多功能都帮你弄好了的,你只需要在主题配置文件_conflg.yml中打开就好\n> \n> 总之,用官方的话来说:简洁但不简单","tags":["hexo主题","hexo"],"categories":["hexo"]},{"title":"「一本通 5.1 例 1」石子合并","url":"/2018/10/23/「一本通 5.1 例 1」石子合并/","content":"\n- 经典的不要不要的\n- 直接套用区间DP模板\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=410;\nint n,f[maxn][maxn],s[maxn],f1[maxn][maxn];\nint main()\n{\n\tscanf(\"%d\",&n);memset(f1,0x3f,sizeof f1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&s[i]);\n\t\ts[i+n]=s[i];\n\t\ts[i]+=s[i-1];\n\t\tf1[i][i]=0;\n\t\tf1[i+n][i+n]=0;\n\t}\n\tfor(int i=1;i<=n;i++)s[i+n]+=s[i+n-1];\n\tfor(int l=1;l<n*2;l++)\n\tfor(int i=1;i+l<=n*2;i++)\n\t{\n\t\tint j=i+l;\n\t\tfor(int k=i;k<j;k++)\n\t\t{\n\t\t\tf[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]);\n\t\t\tf1[i][j]=min(f1[i][j],f1[i][k]+f1[k+1][j]+s[j]-s[i-1]);\n\t\t}\n\t}\n\tint ans=0,bns=f1[0][0];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans=max(ans,f[i][i+n-1]);\n\t\tbns=min(bns,f1[i][i+n-1]);\n\t}\n\tprintf(\"%d\\n%d\\n\",bns,ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTk5MDM3MTU1Nl19\n-->","tags":["区间DP"],"categories":["一本通"]},{"title":"AHOI2017初中组 guide","url":"/2018/10/23/[AHOI2017初中组]guide/","content":"\n### 题意\n\n> 对于一张有向图,每条边有两个边权,有两套GPS会分别按两个边权计算所在到终点的最短路,如果你不按其中一套GPS说的路走,就会产生1的抱怨,求从起点到终点的最少抱怨数\n\n### 题解\n> 因为每次两套GPS都会判断当前要去的点是否在当前点到终点的最短路上,所以我们可以反向建边,跑出每套GPS从终点到每个点的最短路,然后我们重新建图,依次枚举原图的每条边,将边权赋值为2,如果要去的点在某套GPS的最短路上,边权减一.最后跑一遍最短路就可以得出$ans$\n\n- 反向建边\n- 反向SPFA\n- 边重构\n- 反向SPFA\n- $ans$\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m,head[maxn],num;\nint dis[maxn],dis1[maxn],di[maxn];\nbool use[maxn];\nstruct fy{int from,to,d,dd,e,next;}q[maxn*5];\nvoid add(int a,int b,int c,int d)\n{\n\tq[++num]=(fy){a,b,c,d,0,head[a]};head[a]=num;\n}\nvoid sp()\n{\n\tmemset(dis,0x3f,sizeof dis);dis[n]=0;\n\tmemset(dis1,0x3f,sizeof dis1);dis1[n]=0;\n\tqueue<int>qq;qq.push(n);use[n]=true;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]>dis[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n\tqq.push(n);use[n]=true;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis1[b]>dis1[a]+q[i].dd)\n\t\t\t{\n\t\t\t\tdis1[b]=dis1[a]+q[i].dd;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sp1()\n{\n\tmemset(di,0x3f,sizeof di);di[n]=0;\n\tqueue<int>qq;qq.push(n);use[n]=true;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(di[b]>di[a]+q[i].e)\n\t\t\t{\n\t\t\t\tdi[b]=di[a]+q[i].e;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c,d;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tadd(b,a,c,d);\n\t}\n\tsp();//反向SPFA\n\tfor(int i=1;i<=num;i++)//边重构\n\t{\n\t\td=2;a=q[i].from;b=q[i].to;\n\t\tif(dis[b]==dis[a]+q[i].d)d--;\n\t\tif(dis1[b]==dis1[a]+q[i].dd)d--;\n\t\tq[i].e=d;\n\t}\n\tsp1();\n\tprintf(\"%d\\n\",di[1]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTM3NTA2Nzg0NV19\n-->","tags":["最短路"],"categories":["算法学习"]},{"title":"POI working up","url":"/2018/10/23/[POI]working up/","content":"\n### 题意\n> 有两个人和一个$n \\times m$的矩阵,一个从左上角出发,只能向右,向下走,去右下角;另一个从右上角出发只能向左,向下走,去左下角.矩阵的每一格有一个权值,走过会得到这个权值.很显然,两个人肯定会相遇,他们相遇的那一格的权值不取,求两人只相遇一次权值和的最大值\n\n### 题解\n> **读完题,你是否有想到`方格取数`\n> 做法非常简单也非常暴力,开四个二维数组分别记录从四个角出发的最优解,然后$n^2$枚举合法的点,更新$ans$\n> 因为只相遇一次,所以两人相遇时只有两种直线走法,不会转弯**\n- 注意下标,容易迷糊\n- 记得开`long long`\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1010;\nll mp[maxn][maxn],f1[maxn][maxn];\nll f2[maxn][maxn],f3[maxn][maxn];\nll f4[maxn][maxn];\nint n,m;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf(\"%lld\",&mp[i][j]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)\n\tf1[i][j]=max(f1[i-1][j],f1[i][j-1])+mp[i][j];\n\tfor(int i=n;i;i--)for(int j=m;j;j--)\n\tf2[i][j]=max(f2[i+1][j],f2[i][j+1])+mp[i][j];\n\tfor(int i=1;i<=n;i++)for(int j=m;j;j--)\n\tf3[i][j]=max(f3[i-1][j],f3[i][j+1])+mp[i][j];\n\tfor(int i=n;i;i--)for(int j=1;j<=m;j++)\n\tf4[i][j]=max(f4[i+1][j],f4[i][j-1])+mp[i][j];\n\t//暴力美学\n\tll ans=0;\n\tfor(int i=2;i<n;i++)for(int j=2;j<m;j++)\n\t{\n\t\tans=max(ans,f1[i][j-1]+f2[i][j+1]+f3[i-1][j]+f4[i+1][j]);\n\t\tans=max(ans,f1[i-1][j]+f2[i+1][j]+f3[i][j+1]+f4[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMjAxNTEzOTAxMiwtMjExMjg0OTMyMCw4Mz\nExMjc2MzhdfQ==\n-->","tags":["DP"],"categories":["算法学习"]},{"title":"HDU warm up","url":"/2018/10/23/HDU warm up/","content":"\n### 题意\n\n> 有一张联通的无向图,再加一条无向边后最少的桥的数量\n\n- 求桥时将边双缩点,记录桥数 **ans**\n- 建树,求最长路长度 **bns**\n- 答案为 **ans-bns** \n- 多组数据,注意初始化\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10,maxm=1e6+10;\nint n,m,head[maxn],num,cnt,bi,ans;\nint dfn[maxn],low[maxn],input,fa[maxn],pa[maxn];\nint xx[maxn],w,headd[maxn],numm,mdep,ww;\nstruct fy{int from,to,next,h;}q[maxm<<1];\nstruct ffy{int to,next;}qq[maxm<<1];\nvoid add(int a,int b)\n{\n\tq[++num]=(fy){a,b,head[a],++bi};head[a]=num;\n\tq[++num]=(fy){b,a,head[b],bi};head[b]=num;\n}\nvoid addd(int a,int b){qq[++numm]=(ffy){b,headd[a]};headd[a]=numm;}\nvoid tar(int a)\n{\n\tdfn[a]=low[a]=++input;xx[++w]=a;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(q[i].h==pa[a])continue;\n\t\tif(!dfn[b])\n\t\t{\n\t\t\tpa[b]=q[i].h;tar(b);\n\t\t\tlow[a]=min(low[a],low[b]);\n\t\t\tif(dfn[a]<low[b])ans++;\n\t\t}\n\t\telse low[a]=min(low[a],dfn[b]);\n\t}\n\tif(low[a]==dfn[a])\n\t{\n\t\t++cnt;\n\t\twhile(xx[w+1]!=a)\n\t\t{\n\t\t\tfa[xx[w]]=cnt;\n\t\t\tw--;\n\t\t}\n\t}\n}\nvoid dfs(int a,int fat,int dep)\n{\n\tif(dep>mdep)\n\t{\n\t\tmdep=dep;\n\t\tww=a;\n\t}\n\tfor(int i=headd[a];i;i=qq[i].next)\n\t{\n\t\tint b=qq[i].to;if(b==fat)continue;\n\t\tdfs(b,a,dep+1);\n\t}\n}\nint main()\n{\n\tint a,b;\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tmemset(head,0,sizeof head);memset(dfn,0,sizeof dfn);\n\t\tmemset(low,0,sizeof low);memset(pa,0,sizeof pa);\n\t\tmemset(headd,0,sizeof headd);\n\t\tnum=0;cnt=0;bi=0;w=0;input=0;numm=0;ans=0;ww=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{scanf(\"%d%d\",&a,&b);add(a,b);}\n\t\ttar(1);\n\t\tfor(int i=1;i<=num;i++)\n\t\t{\n\t\t\ta=fa[q[i].from];b=fa[q[i].to];\n\t\t\tif(a!=b)addd(a,b);\n\t\t}\n\t\tmdep=0;dfs(1,0,0);\n\t\tmdep=0;dfs(ww,0,0);\n\t\tprintf(\"%d\\n\",ans-mdep);\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE1OTc1ODc0MDddfQ==\n-->","tags":["tarjan"],"categories":["算法学习"]},{"title":"「一本通 1.1 例 1」活动安排","url":"/2018/10/23/「一本通 1.1 例 1」活动安排/","content":"\n### 题解\n\n> - 区间不相交问题\n>\t  - 按右端点排序\n>\t  - 枚举,当左端点未被标记时,$ans++$,标记右端点\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1200;\nint n;\nstruct fy{int x,y;bool operator<(const fy&a)const{return y<a.y;};}q[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);int ans=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&q[i].x,&q[i].y);\n\tsort(q+1,q+1+n);int w=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(q[i].x>=w)\n\t\t{\n\t\t\tans++;\n\t\t\tw=q[i].y;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTg2OTU5MzM5OV19\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 例 2」种树","url":"/2018/10/23/「一本通 1.1 例 2」种树/","content":"\n### 题解\n\n> - 区间选点问题\n>    - 按右端点排序\n>    - 枚举,当该区间未被选够点时,从后往前选择未被选择的点,直到选够\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3e4+10;\nint n,m;\nbool use[maxn]; \nstruct fy{int x,y,d;bool operator<(const fy&a)const{return y<a.y;};}q[maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d%d\",&q[i].x,&q[i].y,&q[i].d);\n\tsort(q+1,q+1+m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=q[i].x;j<=q[i].y;j++)\n\t\t{\n\t\t\tif(use[j])q[i].d--;\n\t\t\tif(!q[i].d)break;\n\t\t}\n\t\tif(q[i].d>0)for(int j=q[i].y;j>=q[i].x;j--)\n\t\t{\n\t\t\tif(!use[j])\n\t\t\t{\n\t\t\t\tuse[j]=true;\n\t\t\t\tq[i].d--;\n\t\t\t\tif(!q[i].d)break;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(use[i])ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n<!--stackedit_data:\neyJoaXN0b3J5IjpbNjQ2MDExMTYyXX0=\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 例 3」喷水装置","url":"/2018/10/23/「一本通 1.1 例 3」喷水装置/","content":"\n### 题解\n\n> -  区间覆盖问题 \n>     - 按左端点排序\n>     - 枚举,选择能覆盖当前节点,右端点最远的节点,将当前节点更新为该最远节点的右端点\n\n### Coding:\n```cpp\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15e3+10;\nint t,n,l,w,cnt,ans;\nstruct fy{double x,y;bool operator<(const fy&a)const{return x<a.x;};}q[maxn];\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tcnt=0;ans=0;\n\t\tdouble a,b;\n\t\tscanf(\"%d%d%d\",&n,&l,&w);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&a,&b);\n\t\t\tif(b*2<=w)continue;\n\t\t\tq[++cnt].x=a-sqrt(b*b-w*w/4.0);\n\t\t\tq[cnt].y=a+sqrt(b*b-w*w/4.0);\n\t\t}\n\t\tdouble now=0,la=0;\n\t\tsort(q+1,q+1+cnt);\n\t\tfor(int i=1;i<=cnt;i++)\n\t\t{\n\t\t\tif(q[i].x>la){ans++;la=now;}\n\t\t\tif(q[i].x<=la)now=max(now,q[i].y);\n\t\t}\n\t\tif(la<l)ans++;\n\t\tif(now<l)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTQzNjEwMzEyOV19\n-->","tags":["贪心","java","ok","mei","okma"],"categories":["一本通","C++","fule"]},{"title":"「一本通 1.1 例 4」加工生产调度","url":"/2018/10/23/「一本通 1.1 例 4」加工生产调度/","content":"\n### 题解\n\n> - 流水作业调度问题\n>  \t- Johnson算法(~~比较迷,反正我没懂~~)\n>  \t- 按$min(i.a,j.b)<min(i.b,j.a)$排序\n>  \t- 枚举记录$ans$\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010;\nint n;\nstruct fy{int x,y,w;}q[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i].x);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i].y);\n\tfor(int i=1;i<=n;i++)q[i].w=i;\n\tfor(int i=1;i<n;++i)for(int j=i+1;j<=n;++j)\n\tif(min(q[i].x,q[j].y)>min(q[i].y,q[j].x)) swap(q[i],q[j]);\n\tint ans=0,bns=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=q[i].x;\n\t\tbns=max(bns,ans);\n\t\tbns+=q[i].y;\n\t}\n\tprintf(\"%d\\n\",bns);\n\tfor(int i=1;i<=n;i++)printf(\"%d \",q[i].w);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE1NzQ2OTcwNTJdfQ==\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 练习 1」数列极差","url":"/2018/10/23/「一本通 1.1 练习 1」数列极差/","content":"\n### 题解\n\n> - 贪心每次取极值\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=5e4+10;\nint n;\nll ans;\nstruct fy\n{\n\tll x;\n\tbool operator<(const fy&a)\n\tconst{return x>a.x;};\n};\nstruct ffy\n{\n\tll x;\n\tbool operator<(const ffy&a)\n\tconst{return x<a.x;};\n};\npriority_queue<fy>q;\npriority_queue<ffy>qq;\nint main()\n{\n\tscanf(\"%d\",&n);ll a,b;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a);\n\t\tq.push((fy){a});\n\t\tqq.push((ffy){a});\n\t}\n\tscanf(\"%lld\",&a);\n\tll ma,mi;\n\twhile(!q.empty())\n\t{\n\t\tma=q.top().x;q.pop();\n\t\tif(q.empty())break;\n\t\tb=q.top().x;q.pop(); \n\t\tq.push((fy){ma*b+1});\n\t}\n\twhile(!qq.empty())\n\t{\n\t\tmi=qq.top().x;qq.pop();\n\t\tif(qq.empty())break;\n\t\tb=qq.top().x;qq.pop();\n\t\tqq.push((ffy){mi*b+1});\n\t}\n\tans=ma-mi;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMzkyMzY0OTQ2XX0=\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 练习 2」数列分段","url":"/2018/10/23/「一本通 1.1 练习 2」数列分段/","content":"\n### 题解\n\n> - 每段尽量装最多\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m,s[maxn],ans;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){scanf(\"%d\",&s[i]);}\n\tint v=m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(v<s[i])\n\t\t{\n\t\t\tans++;\n\t\t\tv=m-s[i];\n\t\t}\n\t\telse v-=s[i];\n//\t\tprintf(\"%d\\n\",v);\n\t}\n\tans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE5NjU1MzI0NjRdfQ==\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 练习 3」线段","url":"/2018/10/23/「一本通 1.1 练习 3」线段/","content":"\n### 题解\n\n> - 区间不相交问题\n>\t  - 按右端点排序\n>\t  - 枚举,当左端点未被标记时,$ans++$,标记右端点\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e6+10;\nint n;\nstruct fy\n{\n\tint x,y;\n\tbool operator<(const fy&a)\n\tconst{return y<a.y;};\n}q[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);int ans=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&q[i].x,&q[i].y);\n\tsort(q+1,q+1+n);int now=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=q[i].x;\n\t\tif(now<=a)\n\t\t{\n\t\t\tans++;\n\t\t\tnow=q[i].y;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTYzNDI4MDY2XX0=\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 练习 4」家庭作业","url":"/2018/10/23/「一本通 1.1 练习 4」家庭作业/","content":"\n### 题解\n\n> - 带限期和罚款的单位时间任务调度\n>     - 按期限排序\n>  \t- 用优先队列维护\n>  \t- 若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队\n>  \t- 若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队\n>  \t- 最后累加队列中的元素权值\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e6+10;\nint n,l;\nstruct fy\n{\n\tint x,y;\n\tbool operator<(const fy&a)\n\tconst{return x<a.x;};\n}q[maxn];\nstruct ffy\n{\n\tint x;\n\tbool operator<(const ffy&a)\n\tconst{return x>a.x;}\n};\npriority_queue<ffy>qq;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&q[i].x,&q[i].y);\n\tsort(q+1,q+1+n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=q[i].x;\n\t\tint b=q[i].y;\n\t\tif(l<a)\n\t\t{\n\t\t\tqq.push((ffy){b});\n\t\t\tl++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint c=qq.top().x;\n\t\t\tif(b>c)\n\t\t\t{\n\t\t\t\tqq.pop();\n\t\t\t\tqq.push((ffy){b});\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\twhile(!qq.empty())\n\t{\n\t\tans+=qq.top().x;\n\t\tqq.pop();\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTEyNDgyMjg0NTZdfQ==\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.1 练习 5」钓鱼","url":"/2018/10/23/「一本通 1.1 练习 5」钓鱼/","content":"\n- 十分巧妙的贪心\n- 单调队列\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=110;\nint n,h,dis[maxn],ans,bns;\nint s[maxn],ss[maxn];\nstruct ffy\n{\n\tint x,y;\n\tbool operator<(const ffy&a)\n\tconst{return x<a.x;};\n};\npriority_queue<ffy>qq;\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);h*=12;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&s[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&ss[i]);\n\tfor(int i=2;i<=n;i++)scanf(\"%d\",&dis[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\th-=dis[i];int time=0;bns=0;\n\t\tfor(int j=1;j<=i;j++)qq.push((ffy){s[j],j});\n\t\twhile(++time<=h&&!qq.empty())\n\t\t{\n\t\t\tint a=qq.top().x;\n\t\t\tint b=qq.top().y;\n\t\t\tif(a<=0)break;\n\t\t\tbns+=a;\n\t\t\tqq.pop();\n\t\t\tqq.push((ffy){a-ss[b],b});\n\t\t}\n\t\tans=max(ans,bns);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTIwMjYzMzQ2MDldfQ==\n-->","tags":["贪心"],"categories":["一本通"]},{"title":"「一本通 1.2 例 1」愤怒的牛","url":"/2018/10/23/「一本通 1.2 例 1」愤怒的牛/","content":"\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10;\nconst double exp=1e-6,inf=1e9;\nint n,m;\ndouble s[maxn],sum[maxn];\nbool can(double a)//分数规划\n{\n\tdouble res=1e10,ans=-1e10;\n\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+s[i]-a;\n\tfor(int i=m;i<=n;i++) {res=min(res,sum[i-m]);ans=max(ans,sum[i]-res);}\n\tif(ans>=0) return true;//寻找一段长度大于等于m,平均数大于等于a的区间\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);double l=inf,r=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lf\",&s[i]);\n\t\tl=min(l,s[i]);r=max(r,s[i]);\n\t}\n\twhile(r-l>=exp)\n\t{\n\t\tdouble mid=(l+r)/2.0;\n\t\tif(can(mid))l=mid;\n\t\telse r=mid;\n\t}\n    int output=(int)(r*(double)1000.0);\n    printf(\"%d\\n\",output);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTY5MTQ4NjkzM119\n-->","tags":["二分"],"categories":["一本通"]},{"title":"「一本通 1.2 例 3」曲线","url":"/2018/10/23/「一本通 1.2 例 3」曲线/","content":"\n### 题解\n> **三分裸题\n可以证明n个函数同一横坐标的最值形成的图像为单峰函数\n精度比较坑,要$10^{-9}$**\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10;\nconst double eps=1e-9;\nint t,n,a[maxn],b[maxn],c[maxn];\ndouble check(double x)\n{\n\tdouble ans=-1e9;\n\tfor(int i=1;i<=n;i++)\n\tans=max(ans,a[i]*x*x+b[i]*x+c[i]);\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d%d%d\",&a[i],&b[i],&c[i]);\n\t\tdouble l=0,r=1000;\n\t\twhile(l+eps<=r)\n\t\t{\n\t\t\tdouble m1=l+(r-l)/3.0;\n\t\t\tdouble m2=r-(r-l)/3.0;\n\t\t\tif(check(m1)<=check(m2))r=m2;\n\t\t\telse l=m1;\n\t\t}\n\t\tprintf(\"%.4lf\\n\",check(l));\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbOTkwNTkwMzUwLC04MDMwNDI3NTJdfQ==\n-->","tags":["三分"],"categories":["一本通"]},{"title":"「一本通 3.1 例 1」黑暗城堡","url":"/2018/10/23/「一本通 3.1 例 1」黑暗城堡/","content":"\n- 最短路径树计数\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010,mod=(1<<31)-1;\nint n,m,head[maxn],num,dis[maxn],sum[maxn];\nlong long ans=1;\nbool use[maxn];\nstruct fy{int to,d,next;}q[maxn*maxn];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp()\n{\n\tqueue<int>qq;qq.push(1);use[1]=true;\n\tmemset(dis,0x3f,sizeof dis);dis[1]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]>dis[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\t\tif(!use[b])\n\t\t\t\t{\n\t\t\t\t\tuse[b]=true;\n\t\t\t\t\tqq.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tadd(a,b,c);add(b,a,c);\n\t}\n\tsp();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=head[i];j;j=q[j].next)\n\t\t{\n\t\t\ta=q[j].to;\n\t\t\tif(dis[a]==dis[i]+q[j].d)sum[a]++;\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)ans=ans*sum[i]%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTk1NjM0MjM3Nl19\n-->","tags":["生成树"],"categories":["一本通"]},{"title":"「一本通 3.1 例 2」北极通讯网络","url":"/2018/10/23/「一本通 3.1 例 2」北极通讯网络/","content":"\n- 树外加点(同通讯网络)\n\n```cpp\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510;\nint n,m,num,fa[maxn];\ndouble x[maxn],y[maxn];\nint find(int a)\n{\n\twhile(fa[a]!=a)a=fa[a]=fa[fa[a]];\n\treturn a;\n}\nstruct fy\n{\n\tint from,to;\n\tdouble d;\n\tbool operator<(const fy &a)const{return d<a.d;};\n}q[maxn*maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%lf\",&x[i],&y[i]);fa[i]=i;\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tdouble a=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);\n\t\t\tq[++num]=(fy){j,i,sqrt(a)};\n\t\t}\n\t}\n\tint ans=0;\n\tsort(q+1,q+1+num);\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tif(a!=b)\n\t\t{\n\t\t\tans++;\n\t\t\tfa[a]=b;\n\t\t\tif(ans==(n-m))\n\t\t\t{\n\t\t\t\tprintf(\"%.2lf\\n\",q[i].d);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"0\\n\");\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE1MDIxODk4NzldfQ==\n-->","tags":["生成树"],"categories":["一本通"]},{"title":"「一本通 3.1 练习 1」新的开始","url":"/2018/10/23/「一本通 3.1 练习 1」新的开始/","content":"\n- 树外加点\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=310;\nint n,v[maxn],head[maxn],num,fa[maxn];\nstruct fy\n{\n\tint from,to,d;\n\tbool operator<(const fy &a)const{return d<a.d;};\n}q[maxn*maxn<<1];\nint find(int a)\n{\n\twhile(fa[a]!=a)a=fa[a]=fa[fa[a]];\n\treturn a;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&v[i]);\n\t\tq[++num]=(fy){0,i,v[i]};\n\t\tfa[i]=i;\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t{\n\t\tscanf(\"%d\",&q[++num].d);\n\t\tq[num].from=i;q[num].to=j;\n\t}\n\tsort(q+1,q+1+num);int ans=0,e=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tif(a!=b)\n\t\t{\n\t\t\te++;\n\t\t\tans+=q[i].d;\n\t\t\tfa[a]=b;\n\t\t\tif(e==n)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMjMwNzc1NzQ3XX0=\n-->","tags":["生成树"],"categories":["一本通"]},{"title":"「一本通 3.1 练习 2」构造完全图","url":"/2018/10/23/「一本通 3.1 练习 2」构造完全图/","content":"\n- 使两点连通的边的权值+1\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1e5+10;\nint n,fa[maxn],size[maxn];\nll ans;\nstruct fy{int from,to,d;bool operator<(const fy &a)const{return d<a.d;};}q[maxn];\nint find(int a)\n{\n\tif(fa[a]!=a)\n\t{\n\t\tsize[fa[a]]+=size[a];\n\t\tsize[a]=0;\n\t\tfa[a]=find(fa[a]);\n\t}\n\treturn fa[a];\n}\nint main()\n{\n\tscanf(\"%d\",&n);int a,b,c;\n\tfor(int i=1;i<=n;i++){fa[i]=i;size[i]=1;}\n\tfor(int i=1;i<n;i++)scanf(\"%d%d%d\",&q[i].from,&q[i].to,&q[i].d);\n\tsort(q+1,q+n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tans+=q[i].d;\n\t\tans+=(ll)(q[i].d+1)*(size[a]*size[b]-1);\n\t\tfa[a]=b;\n\t\tsize[b]+=size[a];\n\t\tsize[a]=0;\n//\t\tfor(int j=1;j<n;j++)printf(\"%d \",size[j]);\n//\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbNzU2MTgxMDUyXX0=\n-->","tags":["生成树"],"categories":["一本通"]},{"title":"「一本通 3.1 练习 3」秘密的牛奶运输","url":"/2018/10/23/「一本通 3.1 练习 3」秘密的牛奶运输/","content":"\n- 次小生成树(最小生成树+LCA)\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=5100,maxm=2e4+10;\nint n,m,head[maxn],num,fa[maxn];\nbool usee[maxm];\nstruct fy{int to,d,next;}e[maxn<<1];\nstruct ffy\n{\n\tint from,to,d;\n\tbool operator<(const ffy &a)const{return d<a.d;};\n}q[maxm];\nint find(int a){while(fa[a]!=a)a=fa[a]=fa[fa[a]];return a;}\nvoid add(int a,int b,int c){e[++num]=(fy){b,c,head[a]};head[a]=num;}\nint pa[maxn][40],ma[maxn][40],dep[maxn];\nvoid dfs(int a,int fat)\n{\n\tpa[a][0]=fat;dep[a]=dep[fat]+1;\n\tfor(int i=1;(1<<i)<=dep[a];i++)\n\t{\n\t\tpa[a][i]=pa[pa[a][i-1]][i-1];\n\t\tma[a][i]=max(ma[a][i-1],ma[pa[a][i-1]][i-1]);\n\t}\n\tfor(int i=head[a];i;i=e[i].next)\n\t{\n\t\tint b=e[i].to;if(b==fat)continue;\n\t\tma[b][0]=e[i].d;dfs(b,a);\n\t}\n\t\n}\nint lca(int a,int b)\n{\n\tint he=0;\n\tif(dep[a]<dep[b])swap(a,b);\n\tfor(int i=25;i>=0;i--)if(dep[pa[a][i]]>=dep[b])\n\t{\n\t\the=max(he,ma[a][i]);\n\t\ta=pa[a][i];\n\t}\n\tif(a==b)return he;\n\tfor(int i=25;i>=0;i--)if(pa[a][i]!=pa[b][i])\n\t{\n\t\the=max(he,max(ma[a][i],ma[b][i]));\n\t\ta=pa[a][i];b=pa[b][i];\n\t}\n\treturn he=max(he,max(ma[a][0],ma[b][0]));\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);for(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d%d\",&q[i].from,&q[i].to,&q[i].d);\n\tsort(q+1,q+1+m);int he=0;ll ans=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tif(a!=b)\n\t\t{\n\t\t\tfa[a]=b;ans+=q[i].d;he++;usee[i]=true;\n\t\t\tadd(q[i].from,q[i].to,q[i].d);add(q[i].to,q[i].from,q[i].d);\n\t\t\tif(he==(n-1))break;\n\t\t}\n\t}\n\tdfs(1,0);int maxl=1e9+7;\n\tfor(int i=1;i<=m;i++)if(!usee[i])\n\t{\n\t\tint a=lca(q[i].from,q[i].to);\n\t\tif(q[i].d-a)maxl=min(maxl,q[i].d-a);\n\t}\n\tprintf(\"%lld\\n\",ans+(ll)maxl);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE1NTMwMDIyMV19\n-->","tags":["生成树"],"categories":["一本通"]},{"title":"「一本通 3.2 例 1」Sightseeing Trip","url":"/2018/10/23/「一本通 3.2 例 1」Sightseeing Trip/","content":"\n- spfa求最小环\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=210,inf=6e8+7;\nint n,m,xx[maxn],w,fa[maxn][maxn];\nll map[maxn][maxn],dis[maxn][maxn],ans=inf;\nvoid floyd()\n{\n\tll he;\n\tfor(int k=1;k<=n;k++)\n\t{\n\t\tfor(int i=1;i<k;i++)for(int j=i+1;j<k;j++)\n\t\t{\n\t\t\the=dis[i][j]+map[j][k]+map[k][i];\n\t\t\tif(he<ans)\n\t\t\t{\n\t\t\t\tans=he;w=0;int a=j;\n\t\t\t\twhile(a!=i){xx[++w]=a;a=fa[i][a];}\n\t\t\t\txx[++w]=i;xx[++w]=k;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t\t{\n\t\t\the=dis[i][k]+dis[k][j];\n\t\t\tif(he<dis[i][j])\n\t\t\t{\n\t\t\t\tdis[i][j]=he;\n\t\t\t\tfa[i][j]=fa[k][j];\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"trip7.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);int a,b;ll c;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t{\n\t\tmap[i][j]=dis[i][j]=inf;\n\t\tfa[i][j]=i;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&a,&b,&c);c=min(c,dis[a][b]);\n\t\tdis[a][b]=dis[b][a]=c;\n\t\tmap[a][b]=map[b][a]=dis[a][b];\n\t}\n\tfloyd();\n\tif(ans==inf)\n\t{\n\t\tprintf(\"No solution.\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=w;i++)printf(\"%d \",xx[i]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMzI0MDMzOTkzXX0=\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 例 3」架设电话线","url":"/2018/10/23/「一本通 3.2 例 3」架设电话线/","content":"\n- 分成图最短路裸题\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010,maxm=2010;\nint n,m,v,head[maxn],num,dis[maxn][maxn];\nbool use[maxn];\nstruct fy{int to,d,next;}q[maxm<<1];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp()\n{\n\tqueue<int>qq;qq.push(1);use[1]=true;\n\tmemset(dis,0x3f,sizeof dis);\n\tfor(int i=0;i<=v;i++)dis[1][i]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tfor(int j=0;j<=v;j++)if(dis[b][j]>max(dis[a][j],q[i].d))\n\t\t\t{\n\t\t\t\tdis[b][j]=max(dis[a][j],q[i].d);\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t\tfor(int j=1;j<=v;j++)if(dis[b][j]>dis[a][j-1])\n\t\t\t{\n\t\t\t\tdis[b][j]=dis[a][j-1];\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&v);int a,b,c;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tadd(a,b,c);add(b,a,c);\n\t}\n\tsp();\n\tif(dis[n][v]!=dis[0][0])printf(\"%d\\n\",dis[n][v]);\n\telse printf(\"-1\\n\");\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTQzMzkyNTQ3Nl19\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 练习 1」农场派对","url":"/2018/10/23/「一本通 3.2 练习 1」农场派对/","content":"\n- 正反向建边\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1010,maxm=1e5+10;\nbool use[maxn];\nint n,m,s,ans,head[maxn],head1[maxn],num,dis[maxn],dis1[maxn];\nstruct fy{int to,d,next;}q[maxm],q1[maxm];\nvoid add(int a,int b,int c)\n{\n\tq[++num]=(fy){b,c,head[a]};head[a]=num;\n\tq1[num]=(fy){a,c,head1[b]};head1[b]=num;\n}\nvoid sp()\n{\n\tqueue<int>qq;qq.push(s);use[s]=true;\n\tmemset(dis,0x3f,sizeof dis);dis[s]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]>dis[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n\twhile(!qq.empty())qq.pop();\n\tmemset(use,false,sizeof use);\n\tqq.push(s);use[s]=true;\n\tmemset(dis1,0x3f,sizeof dis1);dis1[s]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head1[a];i;i=q1[i].next)\n\t\t{\n\t\t\tint b=q1[i].to;\n\t\t\tif(dis1[b]>dis1[a]+q1[i].d)\n\t\t\t{\n\t\t\t\tdis1[b]=dis1[a]+q1[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&s);int a,b,c;\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d%d\",&a,&b,&c);add(a,b,c);}\n\tsp();\n\tfor(int i=1;i<=n;i++)ans=max(ans,dis[i]+dis1[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE4OTAwNDQ1NDRdfQ==\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 练习 2」Roadblocks","url":"/2018/10/23/「一本通 3.2 练习 2」Roadblocks/","content":"\n### 题解\n> **严格次短路问题\n正反建边,跑两次spfa\n枚举两点间的边和分别到终点和起点的距离,更新次短路**\n\n```cpp\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxm=1e5+10,maxn=5e3+10;\nint n,m,ans,head[maxn],num,dis[maxn],dis1[maxn];\nbool use[maxn];\nstruct fy{int to,d,next;}q[maxm<<1];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp()\n{\n\tqueue<int>qq;qq.push(1);use[1]=true;\n\tmemset(dis,0x3f,sizeof dis);dis[1]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]>dis[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n\tqq.push(n);use[n]=true;\n\tmemset(dis1,0x3f,sizeof dis1);dis1[n]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=true;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis1[b]>dis1[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis1[b]=dis1[a]+q[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d%d\",&a,&b,&c);add(a,b,c);add(b,a,c);}\n\tsp();ans=1e9+7;\n\tfor(int i=1;i<=n;i++)for(int j=head[i];j;j=q[j].next)\n\t{\n\t\ta=q[j].to;b=dis[i]+dis1[a]+q[j].d;\n\t\tif(b!=dis[n]&&b<ans)ans=b;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbOTEwMDM5ODIxXX0=\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 练习 3」最短路计数","url":"/2018/10/23/「一本通 3.2 练习 3」最短路计数/","content":"\n- 在最短路的基础上加一个计数\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int maxn=1e6+10;\nint n,m,head[maxn],num,dis[maxn],s[maxn];\nstruct fy{int to,next;}q[maxn<<2];\nstruct ffy{int u,d;bool operator<(const ffy a)const{return d>a.d;};};\npriority_queue<ffy>qq;\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid dj()\n{\n\tmemset(dis,0x3f,sizeof dis);dis[1]=0;s[1]=1;\n\tqq.push((ffy){1,0});\n\twhile(!qq.empty())\n\t{\n\t\tffy a=qq.top();qq.pop();\n\t\tif(a.d!=dis[a.u]) continue;\n\t\tfor(int i=head[a.u];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]>dis[a.u]+1){dis[b]=dis[a.u]+1;s[b]=s[a.u];qq.push((ffy){b,dis[b]});}\n\t\t\telse if(dis[b]==dis[a.u]+1)s[b]=(s[b]+s[a.u])%100003;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int x,y;\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d\",&x,&y);add(x,y);add(y,x);}\n\tdj();\n\tfor(int i=1;i<=n;i++)printf(\"%d\\n\",s[i]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTI1NjU0NzAxNl19\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 练习 4」新年好","url":"/2018/10/23/「一本通 3.2 练习 4」新年好/","content":"\n- 6遍spfa+暴力dfs\n```cpp\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=5e4+10,maxm=1e5+10,inf=1e9+7;\nint n,m,head[maxn],num,ans=inf,dis[6][maxn],s[6];\nstruct fy{int to,d,next;}q[maxm<<1];\nbool use[maxn],ex[10];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp(int a)\n{\n\tqueue<int>qq;qq.push(s[a]);use[s[a]]=true;\n\tmemset(dis[a],0x3f,sizeof dis[a]);dis[a][s[a]]=0;\n\twhile(!qq.empty())\n\t{\n\t\tint b=qq.front();qq.pop();use[b]=false;\n\t\tfor(int i=head[b];i;i=q[i].next)\n\t\t{\n\t\t\tint c=q[i].to;\n\t\t\tif(dis[a][c]>dis[a][b]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[a][c]=dis[a][b]+q[i].d;\n\t\t\t\tif(!use[c]){use[c]=true;qq.push(c);}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int a,int v)\n{\n\tbool can=false;\n\tfor(int i=1;i<=5;i++)if(!ex[i])\n\t{\n\t\tcan=true;\n\t\tex[i]=true;dfs(i,v+dis[a][s[i]]);\n\t\tex[i]=false;\n\t}\n\tif(!can)ans=min(ans,v);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;s[0]=1;\n\tfor(int i=1;i<=5;i++)scanf(\"%d\",&s[i]);\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d%d\",&a,&b,&c);add(a,b,c);add(b,a,c);}\n\tfor(int i=0;i<=5;i++)sp(i);\n\tuse[0]=true;dfs(0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTc1MzMzNzA4OF19\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.2 练习 5」最优贸易","url":"/2018/10/23/「一本通 3.2 练习 5」最优贸易/","content":"\n### 题解\n> **正反建边,两遍spfa,正向记录到每个点的最小值,反向记录到每个点的最大值,最后每个点扫一遍,更新max和min的差值\n正反spfa同时验证了起点到终点的连通性**\n```cpp\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10,maxm=5e5+10;\nint n,m,head[maxn],head1[maxn],num,ans,v[maxn],mal[maxn],mil[maxn];\nbool use[maxn];\nstruct fy{int to,next;}q[maxm<<1],q1[maxm<<1];\nvoid add(int a,int b)\n{\n\tq[++num]=(fy){b,head[a]};head[a]=num;\n\tq1[num]=(fy){a,head1[b]};head1[b]=num;\n}\nvoid sp()\n{\n\tqueue<int>qq;qq.push(1);use[1]=true;\n\tmemset(mil,0x3f,sizeof mil);mil[1]=v[1];\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(mil[b]>min(mil[a],v[b]))\n\t\t\t{\n\t\t\t\tmil[b]=min(mil[a],v[b]);\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n\tqq.push(n);use[n]=true;mal[n]=v[n];\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head1[a];i;i=q1[i].next)\n\t\t{\n\t\t\tint b=q1[i].to;\n\t\t\tif(mal[b]<max(mal[a],v[b]))\n\t\t\t{\n\t\t\t\tmal[b]=max(mal[a],v[b]);\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)ans=max(ans,mal[i]-mil[i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tadd(a,b);if(c==2)add(b,a);\n\t}\n\tsp();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTEzOTA2MjU1MjNdfQ==\n-->","tags":["最短路"],"categories":["一本通"]},{"title":"「一本通 3.4 例 1」Intervals","url":"/2018/10/23/「一本通 3.4 例 1」Intervals/","content":"\n### 题解 \n> - 考虑区间的约束\n> - 由a-b>c等条件 --> dis[[b]>=dis[a]+q[i].d;\n> - 跑spfa\n> - 存在环时无解\n> - 不连通时解为正无穷\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=5e4+10,inf=1e9+7;\nint n,m,head[maxn],num,dis[maxn],s=inf,t;\nbool use[maxn],fl;\nstruct fy{int to,d,next;}q[maxn<<2];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp(int a)\n{\n\tuse[a]=true;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(dis[b]<dis[a]+q[i].d)\n\t\t{\n\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\tsp(b);\n\t\t}\n\t}\n\tuse[a]=false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);int a,b,c;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ts=min(s,a);t=max(t,b);\n\t\tadd(a-1,b,c);\n\t}\n\tfor(int i=s;i<=t;i++) \n\t{add(i-1,i,0);add(i,i-1,-1);}\n\tmemset(dis,-1,sizeof dis);dis[s-1]=0;\n\tsp(s-1);\n\tprintf(\"%d\\n\",dis[t]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTQxMzkwODY3Ml19\n-->","tags":["差分约束"],"categories":["一本通"]},{"title":"「一本通 3.4 练习 1」糖果","url":"/2018/10/23/「一本通 3.4 练习 1」糖果/","content":"\n- 差分裸题\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m,head[maxn],num;\nll dis[maxn];\nbool use[maxn],fl,vis[maxn];\nstruct fy{int to,d,next;}q[maxn<<1];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nvoid sp(int a)\n{\n\tuse[a]=true;vis[a]=true;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(dis[b]<dis[a]+q[i].d)\n\t\t{\n\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\tif(use[b]){fl=true;return;}\n\t\t\tsp(b);\n\t\t\tif(fl)return;\n\t\t}\n\t}\n\tuse[a]=false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&c,&a,&b);\n\t\tif(c==1){add(a,b,0);add(b,a,0);}\n\t\tif(c==2){add(a,b,1);}\n\t\tif(c==3){add(b,a,0);}\n\t\tif(c==4){add(b,a,1);}\n\t\tif(c==5){add(a,b,0);}\n\t\tif(a==b&&!c%2)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i])\n\t{dis[i]=1;sp(i);}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)ans+=dis[i];\n\tif(fl)printf(\"-1\\n\");\n\telse printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTczMDYyMDIxXX0=\n-->","tags":["差分约束"],"categories":["一本通"]},{"title":"「一本通 3.6 例 1」分离的路径","url":"/2018/10/23/「一本通 3.6 例 1」分离的路径/","content":"\n### 题解\n> **除了打人,我什么都不想干\n我开始怀疑割边的定义**\n\n- 割边\n- 有重边 ~(虽然只有一组)~\n- 边双联通分量\n- 度数统计\n- 将一个有割边的无向图转化成边双联通图至少加 **(leaf+1)/2**条边~(leaf表示将边双缩点后形成的树的叶子节点数)~\n\n```cpp\n#include<cstdio>\n#include<stack>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=5e3+10;\nint n,m,head[maxn],num,bi,cnt,ans,fa[maxn],in[maxn];\nbool use[maxn<<2];\nint dfn[maxn],low[maxn],input,xx[maxn],w,pa[maxn];\nstruct fy{int from,to,next,h;}q[maxn<<2];\nvoid add(int a,int b)\n{\n\tq[++num]=(fy){a,b,head[a],++bi};head[a]=num;\n\tq[++num]=(fy){b,a,head[b],bi};head[b]=num;\n}\nvoid tar(int a)\n{\n\tdfn[a]=low[a]=++input;xx[++w]=a;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(q[i].h==pa[a])continue;//说吧,你这个条件要哪样,你真的是割边?(想哭)\n\t\t//就你最皮\n\t\tif(!dfn[b]){pa[b]=q[i].h;tar(b);low[a]=min(low[a],low[b]);}\n\t\telse low[a]=min(low[a],dfn[b]);\n\t}\n\tif(dfn[a]==low[a])\n\t{\n\t\tcnt++;\n\t\twhile(xx[w+1]!=a)\n\t\t{fa[xx[w]]=cnt;w--;}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);\n\t}\n\ttar(1);\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\ta=fa[q[i].from];\n\t\tb=fa[q[i].to];\n\t\tif(a!=b)in[b]++;\n\t}\n\tfor(int i=1;i<=cnt;i++)if(in[i]==1)ans++;\n\tprintf(\"%d\\n\",(ans+1)/2);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTEyMDUzNjY3MzJdfQ==\n-->","tags":["tarjan"],"categories":["一本通"]},{"title":"「一本通 3.6 练习 1」网络","url":"/2018/10/23/「一本通 3.6 练习 1」网络/","content":"\n- 求割点\n- 没了\n\n非常裸的一道割点\n读入有点恶心\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=200;\nint n,m,head[maxn],num,root,ans;\nchar str[maxn<<2];\nbool use[maxn];\nint dfn[maxn],low[maxn],input;\nstruct fy{int to,next;}q[maxn*maxn];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid tar(int a,int fa)\n{\n\tdfn[a]=low[a]=++input;int ch=0;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(!dfn[b])\n\t\t{\n\t\t\tch++;\n\t\t\ttar(b,a);low[a]=min(low[a],low[b]);\n\t\t\tif((root==a&&ch>1)||(root!=a&&dfn[a]<=low[b]))\n\t\t\tif(!use[a])use[a]=true,ans++;\n\t\t}\n\t\telse if(b!=fa) low[a]=min(low[a],dfn[b]);\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d\",&n)==1)\n\t{\n\t\tif(n==0)break;int a,b;\n\t\tmemset(head,0,sizeof head);num=0;ans=0;\n\t\tmemset(dfn,0,sizeof dfn);memset(low,0,sizeof low);input=0;\n\t\tmemset(use,false,sizeof use);\n\t\twhile(scanf(\"%d\",&a)&&a)\n\t\t{\n\t\t\tgets(str);int l=strlen(str);int x=0;\n\t\t\twhile(x<l)\n\t\t\t{\n\t\t\t\twhile(str[x]<'0'||str[x]>'9')x++;\n\t\t\t\tint b=0;\n\t\t\t\twhile(str[x]>='0'&&str[x]<='9')\n\t\t\t\t{b*=10;b+=str[x]-'0';x++;}\n\t\t\t\tadd(a,b);add(b,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)if(!dfn[i]){root=i;tar(i,0);}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTgzMjk1MjM5Ml19\n-->","tags":["tarjan"],"categories":["一本通"]},{"title":"Picnic Planning","url":"/2018/10/23/Picnic Planning/","content":"\n### 题意\n> 矮人虽小却喜欢乘坐巨大的轿车，车大到能够装下不管多少矮人。某天，N(N≤20)个矮人打算到野外聚餐。为了集中到聚餐地点，矮人A 要么开车到矮人B 家中，留下自己的轿车在矮人B 家，然后乘坐B 的轿车同行；要么直接开车到聚餐地点，并将车停放在聚餐地。尽管矮人的家非常大，能够停放无数量轿车，可是聚餐地点却最多仅仅能停放K 辆轿车。给你一张加权无向图，描写叙述了N 个矮人的家和聚餐地点，求出全部矮人开车最短总路程\n\n### 题解\n> **题本身是一道$k$限制生成树裸题,但那东西太迷幻,不会.因为数据规模比较小,暴力能过,所以也没学.这里用的是状压$+Prim$.**\n> **因为根节点只能连不大于$k$条边,所以我们暴力枚举根节点能连的边的状态,再将剩下的点跑最小生成树,更新最小代价.**\n\n- 用$map$映射每个人的名字\n- 可能有重边,需要更新两点之间的最短距离\n- 这里我们用邻接矩阵存边,用$Prim$跑最小生成树,不然时间复杂度过不去\n- 每次生成树必须加够$N-1$条边后才能更新$ans$\n- 输出应遵循题目规则\n\n```cpp\n#include<cstdio>\n#include<map>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\nconst int maxn=430;\nint n,k,num,cnt;\nint fa[22],ans,bns;\nmap< string , int >mm;\nint ss[22][22];\nstruct fy\n{\n\tint from,to,d;\n\tbool operator<(const fy&a)const{return d<a.d;};\n}q[maxn];\nchar str[30],str1[30];\nvoid add(int a,int b,int c){q[++num]=(fy){a,b,c};}\nint can(int a)\n{\n\tbns=0;\n\tint he=0,w=1;\n\twhile(a)\n\t{\n\t\t++w;\n\t\tif(a&1)\n\t\t{\n\t\t\the++;fa[w]=1;\n\t\t\tif(ss[1][w]==ss[0][0])return 0;\n\t\t\tbns+=ss[1][w];\n\t\t}\n\t\ta>>=1;\n\t}\n\tif(he<=k)return he;\n\treturn 0;\n}\nint find(int a)\n{\n\twhile(a!=fa[a])a=fa[a]=fa[fa[a]];\n\treturn a;\n}\nvoid ku(int x)//披着羊皮的狼(滑稽)\n{\n\tif(!x)return;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(q[i].from==1||q[i].to==1)continue;\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tif(a!=b)\n\t\t{\n\t\t\tif(x==(cnt-1))break;\n\t\t\tfa[a]=b;\n\t\t\tx++;\n\t\t\tbns+=q[i].d;\n\t\t\tif(bns>ans)return;\n\t\t}\n\t}\n\tif(x==(cnt-1))ans=min(ans,bns);\n}\nint main()\n{\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tmm.clear();cnt=0;num=0;\n\t\tscanf(\"%d\",&n);memset(ss,0x3f,sizeof ss);\n\t\tmm[\"Park\"]=++cnt;ans=ss[0][0];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%s%s%d\",str,str1,&c);\n\t\t\tif(!mm[str])mm[str]=++cnt;\n\t\t\tif(!mm[str1])mm[str1]=++cnt;\n\t\t\ta=mm[str];b=mm[str1];\n\t\t\tss[a][b]=min(ss[a][b],c);\n\t\t\tss[b][a]=ss[a][b];\n\t\t}\n\t\tscanf(\"%d\",&k);\n\t\tfor(int i=1;i<=cnt;i++)for(int j=i+1;j<=cnt;j++)\n\t\tif(ss[i][j]&&(ss[i][j]!=ss[0][0]))add(i,j,ss[i][j]);\n\t\tsort(q+1,q+1+num);\n\t\tfor(int s=0;s<(1<<(cnt-1));s++)//枚举根节点的状态\n\t\t{\n\t\t\tfor(int i=1;i<=cnt;i++)fa[i]=i;\n\t\t\tku(can(s));\n\t\t}\n\t\tprintf(\"Total miles driven: %d\\n\",ans);//输出\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTIwNTg2NDcyMTddfQ==\n-->","tags":["生成树"],"categories":["算法学习"]},{"title":"「一本通 5.1 例 2」能量项链","url":"/2018/10/23/「一本通 5.1 例 2」能量项链/","content":"\n- 同石子合并\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=210;\nint n,f[maxn][maxn];\nint ll[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&ll[i]);\n\t\tll[i+n]=ll[i];\n\t}\n\tfor(int l=1;l<n*2;l++)\n\tfor(int i=1;i+l<=n*2;i++)\n\t{\n\t\tint j=i+l;\n\t\tfor(int k=i;k<j;k++)\n\t\tf[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+ll[i]*ll[k+1]*ll[j+1]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)ans=max(ans,f[i][i+n-1]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTg0NjIxOTA1Ml19\n-->","tags":["区间DP"],"categories":["一本通"]},{"title":"「一本通 5.1 练习 1」括号配对","url":"/2018/10/23/「一本通 5.1 练习 1」括号配对/","content":"\n- 个人觉得比较迷幻\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=210;\nint n,f[maxn][maxn];\nchar str[maxn];\nint main()\n{\n\tscanf(\"%s\",str+1);n=strlen(str+1);\n\tfor(int i=1;i<=n;i++)f[i][i]=1;\n\tfor(int l=1;l<n;l++)for(int i=1;i+l<=n;i++)\n\t{\n\t\tint j=i+l;\n\t\tf[i][j]=0x7fffffff;for(int k=i;k<j;k++)\n\t\tf[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);\n\t\tif((str[i]=='('&&str[j]==')')||(str[i]=='['&&str[j]==']'))\n\t\tf[i][j]=min(f[i][j],f[i+1][j-1]);\n\t}\n\tprintf(\"%d\\n\",f[1][n]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTExNDYwNzIwNzFdfQ==\n-->","tags":["区间DP"],"categories":["一本通"]},{"title":"「一本通 5.1 练习 3」矩阵取数游戏","url":"/2018/10/23/「一本通 5.1 练习 3」矩阵取数游戏/","content":"\n### 题解\n\n> 我做这道题的路途十分~~坎坷~~平坦\n> \n> 我曾多次点进这道题目,但一直没下定把它A掉 ~~(因为太懒.......好吧,其实是我太弱)~~\n> \n> 直到有一天,一个人让我下点决心\n> \n> 教练给我们出了一套题,其中就有这道,其他同学愉快的AK,我只写了个暴力,40.....\n> \n> ### **言归正传**\n> \n> 很显然这是一道区间DP ~~(没看出来的我还真是抱歉)~~\n> \n> 又因为取数的操作每一行不会相互影响,所以可以每一行独立求解,最后把每行的最优解累加得出结果\n> \n> 对于一个区间 **[i,j]** ,无外乎两种选择,选左边或右边,再结合题意,DP方程就很明白\n> \n> 我们用**f[i,j]** 表示区间**[i,j]** 所能得到的最大结果,**s[i]** 存储区间的数,DP方程为\n> \n> $$f[i,j]=max((f[i+1,j]+s[i])<<1),(f[i,j-1]+s[j])<<1))$$\n> \n> 如果只是单纯的区间DP,那么就很简单,十几行代码轻松搞定.蛋柿,long\n> long只能过60,想体验AC的快感就必须用高精,这大概也是很多人对此题望而却步的原因\n> \n> 我看到很多**dalao**的题解用到了**int128**,用起来确实非常方便,但还是建议还在CCF比赛中水深火热的OIer们少用,因为在CCF的比赛中不允许**int128**,还是老老实实地打高精吧\n> \n> 话不多说上代码~~(代码很丑,dalao勿喷)~~\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int maxn=88;//看起来很吉利的样子 \nint n,m; \nint f[maxn][maxn][maxn],s[maxn],su[maxn][maxn];\n//f表示区间[i,j]的最大结果,多开一维便于打高精;su储存s拆开的每一位上的数 \nint g1[maxn],g2[maxn],ans[maxn];//ans储存答案,g1,g2中间过渡答案; \n\nvoid fu(int a)//将每一个数拆分装进su数组 a表示s的下标 \n{\n\tint w=0;//位数 \n\twhile(s[a])\n\t{\n\t\tsu[a][++w]=s[a]%10;\n\t\ts[a]/=10;\n\t}\n\tsu[a][0]=w;\n}\n\nvoid xx(int a,int b)//高精乘法处理倍增(其实可以用高精加法) a,b表示正在转移的区间 \n{\n\tfor(int i=1;i<=f[a][b][0];i++) \n\tf[a][b][i]*=2;\n\tfor(int i=1;i<=f[a][b][0];i++) \n\t{\n\t\tf[a][b][i+1]+=f[a][b][i]/10;\n\t\tf[a][b][i]=f[a][b][i]%10;\n\t}\n\tif(f[a][b][f[a][b][0]+1]) f[a][b][0]+=1;\n\t//第0位储存该高精数的位数\n}\n\nvoid make(int a,int b)//DP转移 a,b表示正在转移的区间 \n{\n\tint l1=max(f[a+1][b][0],su[a][0]);\n\tint l2=max(f[a][b-1][0],su[b][0]);\n\tint gg=1;//gg表示f[a][b]取f[j+1][j+k]+s[j]<<1还是f[j][j+k-1]+s[j+k]<<1 \n\tmemset(g1,0,sizeof g1);//清空过渡数组\n\tmemset(g2,0,sizeof g2); \n\tfor(int i=1;i<=l1;i++)//高精加法 f[j+1][j+k]+s[j]\n\t{\n\t\tg1[i]+=f[a+1][b][i]+su[a][i];\n\t\tg1[i+1]+=g1[i]/10;\n\t\tg1[i]%=10;\n\t}\n\tif(g1[l1+1]) l1++;//记录高精数的位数 \n\tg1[0]=l1;\n\tfor(int i=1;i<=l2;i++)//高精加法 f[j][j+k-1]+s[j+k] \n\t{\n\t\tg2[i]+=f[a][b-1][i]+su[b][i];\n\t\tg2[i+1]+=g2[i]/10;\n\t\tg2[i]%=10;\n\t}\n\tif(g2[l2+1]) l2++;//记录高精数的位数 \n\tg2[0]=l2;\n\tif(g1[0]>g2[0]) gg=1;//比较 f[j+1][j+k]+s[j]和f[j][j+k-1]+s[j+k]大小 决定f[a][b]取舍 \n\telse if(g1[0]<g2[0]) gg=2;\n\telse \n\t{\n\t\tfor(int i=g1[0];i;i--)\n\t\tif(g1[i]>g2[i]) {gg=1;break;}\n\t\telse if(g1[i]<g2[i]) {gg=2;break;}\n\t}\n\tif(gg==1) for(int i=0;i<=g1[0];i++) f[a][b][i]=g1[i];\n\telse for(int i=0;i<=g2[0];i++) f[a][b][i]=g2[i];\n\txx(a,b);//将结果倍增 \n}\n\nvoid add(int a,int b)//高精加法,累加每一行的最优解 \n{\n\tint l=max(ans[0],f[a][b][0]);\n\tfor(int i=1;i<=l;i++)\n\t{\n\t\tans[i]+=f[a][b][i];\n\t\tans[i+1]+=ans[i]/10;\n\t\tans[i]%=10;\n\t}\n\tif(ans[l+1]) l++;\n\tans[0]=l;//记录答案位数 \n}\n\nint main()//主程序 \n{\n//\tfreopen(\"game.in\",\"r\",stdin);\n//\tfreopen(\"game.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\twhile(n--)\n\t{\n\t\tmemset(su,0,sizeof su);//清空数组 \n\t\tmemset(f,0,sizeof f);\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&s[i]);\n\t\t\tfu(i);//将s[i]拆分 \n\t\t}\n\t\tfor(int k=0;k<m;k++)\n\t\t\tfor(int j=1;j+k<=m;j++)\n\t\t\t\tmake(j,j+k);//DP方程转移 \n//\t\tf[j][j+k]=max(f[j+1][j+k]+s[j]<<1,f[j][j+k-1]+s[j+k]<<1);\n\t\tadd(1,m);//累加最优解 \n//\t\tans+=f[1][m];\n\t}\n\tfor(int i=ans[0];i;i--)//输出答案 \n\tprintf(\"%d\",ans[i]);\n\tif(ans[0]==0) printf(\"0\\n\");//特判是否为0 \n\treturn 0;\n}\n```\n\n丑陋的代码!!!\n\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMjA3MDIyMzI3MF19\n-->","tags":["区间DP"],"categories":["一本通"]},{"title":"「一本通 5.2 例 1」二叉苹果树","url":"/2018/10/23/「一本通 5.2 例 1」二叉苹果树/","content":"\n- 树形背包\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=110;\nint n,m,head[maxn],num,f[maxn][maxn];\nstruct fy{int to,d,next;}q[maxn<<1];\nvoid add(int a,int b,int c){q[++num]=(fy){b,c,head[a]};head[a]=num;}\nint dfs(int a,int fa)\n{\n\tint sum=1;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(b==fa)continue;\n\t\tf[b][1]=q[i].d;sum+=dfs(b,a);\n\t\tfor(int j=sum;j>0;j--)for(int k=0;k<j;k++)\n\t\tf[a][j]=max(f[a][j],f[a][j-k]+f[b][k]);\n\t}\n\treturn sum;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\tfor(int i=1;i<n;i++){scanf(\"%d%d%d\",&a,&b,&c);add(a,b,c);add(b,a,c);}\n\tdfs(1,0);\n\tprintf(\"%d\",f[1][m+1]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTA0NTA2MzQyMV19\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.2 例 2」选课","url":"/2018/10/23/「一本通 5.2 例 2」选课/","content":"\n- 还是树形背包\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=1010;\nint n,m,head[maxn],num,p[maxn],f[maxn][maxn];\nstruct fy{int to,next;}q[maxn];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nint dfs(int a)\n{\n\tint sum=1;f[a][1]=p[a];\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;sum+=dfs(b);\n\t\tfor(int j=sum;j>=1;j--)for(int k=j-1;k>=0;k--)\n\t\tf[a][j]=max(f[a][j],f[a][j-k]+f[b][k]);\n\t}\n\treturn sum;\n}\nint main()\n{\n\tscanf(\"%d%d\",&m,&n);int x,y;\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d\",&x,&p[i]);add(x,i);}\n\tdfs(0);printf(\"%d\\n\",f[0][n+1]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE3ODYyOTA4MjJdfQ==\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.2 例 3」数字转换","url":"/2018/10/23/「一本通 5.2 例 3」数字转换/","content":"\n### 题解\n> **树上找最长链,也就是树的直径\n两边dfs\n第一遍从任意点出发找当前最远点\n第二遍从上一遍的最远点出发找最长链\n可以证明该链为树的一条直径\n~~我不会证明~~\n暴力加边就好**\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int maxn=5e4+10;\nint n,head[maxn],num,w,l;\nstruct fy{int to,next;}q[maxn<<1];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid dfss(int a,int fa,int dep)\n{\n\tif(dep>l){l=dep;w=a;}\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(b==fa)continue;\n\t\tdfss(b,a,dep+1);\n\t}\n}\nint dfs(int a,int fa)\n{\n\tint ans=0;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(b==fa)continue;\n\t\tans=max(ans,dfs(b,a));\n\t}\n\treturn ans+1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=sqrt(i),b=0;\n\t\tfor(int j=1;j<=a;j++)if(i%j==0)\n\t\t{\n\t\t\tb+=j;\n\t\t\tif(i/j!=j&&i/j!=i)b+=i/j;\n\t\t}\n\t\tif(b<i&&b)add(i,b),add(b,i);\n\t}\n\tdfss(1,n+1,0);\n\tprintf(\"%d\",dfs(w,n+1)-1);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTExNjE5MzY3MDhdfQ==\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.2 例 4」战略游戏","url":"/2018/10/23/「一本通 5.2 例 4」战略游戏/","content":"\n> **树的最小点覆盖问题\nDP,贪心,二分图都可以做\n二分图比较简单\n利用二分图的最大匹配数值上等于最小点覆盖的性质**\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1510;\nint n,p[maxn],head[maxn],num,ans;\nbool ex[maxn],use[maxn];\nstruct fy{int to,next;}q[maxn<<1];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nbool find(int a)\n{\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(!use[b])\n\t\t{\n\t\t\tuse[b]=true;\n\t\t\tif(!p[b]||find(p[b]))\n\t\t\t{\n\t\t\t\tp[b]=a;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);int a,b,c;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);a++;ex[a]=true;\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&c);c++;ex[c]=true;\n\t\t\tadd(a,c);add(c,a);\n\t\t}\n\t}\n\tfor(int i=1;i<=1500;i++)if(ex[i])\n\t{\n\t\tmemset(use,false,sizeof use);\n\t\tif(find(i))ans++;\n\t}\n\tprintf(\"%d\\n\",ans/2);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTU5Mzc2MTgwN119\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.2 练习 2」旅游规划","url":"/2018/10/23/「一本通 5.2 练习 2」旅游规划/","content":"\n### 题解\n> **求树的所有直径\n记录三个d\nd1:他到他的子树中的最长距离\nd2:他到他的子树中的次长距离\nd3:他绕过父亲的最长距离\n如果d1+max(d2+d3)==直径,输出**\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,head[maxn],num,d1[maxn],d2[maxn],d3[maxn],ans;\nstruct fy{int to,next;}q[maxn<<1];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid dfs(int a,int fa)\n{\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(b==fa)continue;\n\t\tdfs(b,a);\n\t\tif(d1[b]+1>=d1[a])\n\t\t{\n\t\t\td2[a]=d1[a];\n\t\t\td1[a]=d1[b]+1;\n\t\t}\n\t\telse if(d1[b]+1>d2[a])d2[a]=d1[b]+1;\n\t\tans=max(ans,d1[a]+d2[a]);\n\t}\n}\nvoid dfs1(int a,int fa)\n{\n\tint sum=0;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(b!=fa&&d1[a]==d1[b]+1)sum++;\n\t}\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;if(b==fa)continue;\n\t\tif(sum==1&&d1[a]==d1[b]+1)d3[b]=max(d2[a],d3[a])+1;\n\t\telse d3[b]=max(d1[a],d3[a])+1;\n\t\tdfs1(b,a);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);int a,b;\n\tfor(int i=1;i<n;i++){scanf(\"%d%d\",&a,&b);a++;b++;add(a,b);add(b,a);}\n\tdfs(1,0);dfs1(1,0);\n\tfor(int i=1;i<=n;i++)if(ans==d1[i]+max(d2[i],d3[i]))printf(\"%d\\n\",i-1);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTM1ODUxNDAxXX0=\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.2 练习 3」周年纪念晚会","url":"/2018/10/23/「一本通 5.2 练习 3」周年纪念晚会/","content":"\n> **没有上司的舞会改了名\nf[i][0]:这个人去\nf[i][1]:这个人不去**\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=6010;\nint n,head[maxn],num,f[maxn][2],in[maxn],v[maxn];\nstruct fy{int to,next;}q[maxn];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid dfs(int a)\n{\n\tif(v[a])f[a][1]=v[a];\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;dfs(b);\n\t\tf[a][0]+=max(f[b][0],f[b][1]);\n\t\tf[a][1]+=f[b][0];\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);int a,b;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\twhile(scanf(\"%d%d\",&b,&a))\n\t{\n\t\tif(!a&&!b)break;\n\t\tadd(a,b);in[b]++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(!in[i])\n\t{\n\t\tdfs(i);\n\t\tans+=max(f[i][0],f[i][1]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbOTAwMjMzOTY2XX0=\n-->","tags":["树形DP"],"categories":["一本通"]},{"title":"「一本通 5.4 例 1」骑士","url":"/2018/10/23/「一本通 5.4 例 1」骑士/","content":"\n枚举每一层的每一个状态,合法就处理\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n,m,num[1<<10];ll f[12][1<<10][12*12];\nbool use[1<<10];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<(1<<n);i++)if(!(i&(i<<1)))\n\t{\n\t\tuse[i]=true;int t=i;\n\t\twhile(t){if(t&1)num[i]++;t>>=1;}\n\t\tf[1][i][num[i]]=1;\n\t}\n\tfor(int i=2;i<=n;i++)\n\tfor(int j=0;j<(1<<n);j++)if(use[j])\n\tfor(int k=0;k<(1<<n);k++)if(use[k]&&!(j&k)&&!(j&(k<<1))&&!(j&(k>>1)))\n\tfor(int l=0;l<=m;l++)\n\tf[i][j][num[j]+l]+=f[i-1][k][l];\n\tll ans=0;\n\tfor(int i=0;i<(1<<n);i++)ans+=f[n][i][m];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTc2MTExNzUyM119\n-->","tags":["状压DP"],"categories":["一本通"]},{"title":"「一本通 5.4 例 2」牧场的安排","url":"/2018/10/23/「一本通 5.4 例 2」牧场的安排/","content":"\n同骑士\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n,m,map[14][14],inf=1e8,f[14][1<<12][14*14],num[1<<12],s[14];\nbool use[1<<12];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++){scanf(\"%d\",&a);s[i]<<=1;s[i]|=(!a);}\n\t}\n\tfor(int i=0;i<(1<<m);i++)if(!(i&(i<<1)))\n\t{\n\t\tuse[i]=true;int t=i;\n\t\twhile(t){if(t&1)num[i]++;t>>=1;}\n\t\tif(!(i&s[1]))f[1][i][num[i]]=1;\n\t}\n\tfor(int i=2;i<=n;i++)\n\tfor(int j=0;j<(1<<m);j++)if(use[j]&&!(j&s[i]))\n\tfor(int k=0;k<(1<<m);k++)if(use[k]&&!(k&s[i-1])&&!(j&k))\n\tfor(int l=0;l<=n*m;l++)f[i][j][num[j]+l]+=f[i-1][k][l];\n\tint ans=0;\n\tfor(int i=0;i<(1<<m);i++)for(int j=0;j<=n*m;j++)ans+=f[n][i][j];\n\tprintf(\"%d\\n\",ans%inf);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbODgxODcxMTA0XX0=\n-->","tags":["状压DP"],"categories":["一本通"]},{"title":"「一本通 5.4 练习 1」涂抹果酱","url":"/2018/10/23/「一本通 5.4 练习 1」涂抹果酱/","content":"\n方法同二维,但状态由二维变成三维\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=1e4+10,maxm=243,inf=1e6;\nint mod[6]={0,3,9,27,81,243};\nint n,m,p,f[maxn][maxm],s[maxn];\nbool use[maxm];\nbool ok(int a)\n{\n\tint b=a%3;a/=3;int c=a%3;\n\tfor(int i=2;i<=m;i++)\n\t{\n\t\tif(b==c)return false;\n\t\tb=c;a/=3;c=a%3;\n\t}\n\treturn true;\n}\nbool can(int a,int b)\n{\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a%3,y=b%3;\n\t\tif(x==y)return false;\n\t\ta/=3;b/=3;\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&p);int a;\n\tfor(int i=1;i<=m;i++){scanf(\"%d\",&a);s[p]*=3;s[p]+=a-1;}\n\tif(!ok(s[p]))\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<mod[m];i++)if(ok(i))use[i]=true;;\n\tif(p==1) f[1][s[p]]=1;\n\telse for(int i=0;i<mod[m];i++)if(use[i])f[1][i]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i==p)\n\t\t{\n\t\t\tfor(int j=0;j<mod[m];j++)if(use[j]&&can(s[p],j))\n\t\t\t{f[i][s[p]]+=f[i-1][j];f[i][s[p]]%=inf;}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<mod[m];j++)if(use[j])\n\t\tfor(int k=0;k<mod[m];k++)if(use[k]&&can(j,k))\n\t\t{\n\t\t\tf[i][j]+=f[i-1][k];\n\t\t\tf[i][j]%=inf;\n\t\t}\n\t}\n\tint ans=0;for(int i=0;i<mod[m];i++)if(use[i]){ans+=f[n][i];ans%=inf;}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTczNzU4OTI4M119\n-->","tags":["状压DP"],"categories":["一本通"]},{"title":"「一本通 5.4 练习 2」炮兵阵地","url":"/2018/10/23/「一本通 5.4 练习 2」炮兵阵地/","content":"\n同时枚举两行的状态\n合法就处理\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define mm (1<<m)\nusing namespace std;\nint n,m,f[110][1<<10][1<<10],num[1<<10],s[110],p[1<<10],cnt;\nchar str[15];\ntemplate<typename T> inline bool checkMax(T& a, const T& b) {\n    return a < b ? a = b, true : false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tfor(int j=0;j<m;j++){s[i]<<=1;s[i]|=(str[j]=='P'?0:1);}\n\t}\n\tfor(int i=0;i<mm;i++)if(!((i&(i<<1))||(i&(i<<2))))\n\t{\n\t\tint t=i;p[++cnt]=i;\n\t\twhile(t){if(t&1)num[cnt]++;t>>=1;}\n\t}\n\tfor(register int i=1;i<=cnt;i++)if(!(p[i]&s[1]))\n\t\tfor(register int j=1;j<=cnt;j++)if(!(p[i]&p[j])&&!(p[j]&s[2]))\n\t\t\tf[2][p[i]][p[j]]=num[j]+num[i];\n\tfor(register int i=3;i<=n;i++)\n\t\tfor(register int j=1;j<=cnt;j++)if(!(p[j]&s[i]))\n\t\t\tfor(register int k=1;k<=cnt;k++)if(!(p[j]&p[k])&&!(p[k]&s[i-1]))\n\t\t\t\tfor(register int l=1;l<=cnt;l++)if(!(p[k]&p[l])&&!(p[l]&s[i-2])&&!(p[l]&p[j]))\n\t\t\t\t\tcheckMax(f[i][p[k]][p[j]],f[i-1][p[l]][p[k]]+num[j]);\n\tint ans=0;\n\tfor(int i=1;i<=cnt;i++)if(!(s[n-1]&p[i]))\n\t\tfor(int j=1;j<=cnt;j++)if(!(p[i]&p[j])&&!(s[n]&p[j]))\n\t\t\tcheckMax(ans,f[n][p[i]][p[j]]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTg1MzE4NDMzMF19\n-->","tags":["状压DP"],"categories":["一本通"]},{"title":"元旦晚会","url":"/2018/10/23/元旦晚会/","content":"\n### 题意\n> [**P1986**  元旦晚会](https://www.luogu.org/problemnew/show/P1986)\n\n- 差分约束\n- 最长路\n\n差分裸题\n\n> 1. dis[i]>=dis[i-1]\n> 2. dis[i]-dis[i-1]<=1\n> 3. dis[b]-dis[a-1]>=c\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3e4+10,inf=-1e9;\nint n,m,head[maxn],num,root,dis[maxn];\nbool use[maxn];\nstruct fy{int from,to,d,next;}q[maxn<<2];\nvoid add(int a,int b,int c){q[++num]=(fy){a,b,c,head[a]};head[a]=num;}\nvoid sp()\n{\n\tfor(int i=1;i<=n;i++)dis[i]=inf;dis[root]=0;\n\tqueue<int>qq;qq.push(root);use[root]=true;\n\twhile(!qq.empty())\n\t{\n\t\tint a=qq.front();qq.pop();use[a]=false;\n\t\tfor(int i=head[a];i;i=q[i].next)\n\t\t{\n\t\t\tint b=q[i].to;\n\t\t\tif(dis[b]<dis[a]+q[i].d)\n\t\t\t{\n\t\t\t\tdis[b]=dis[a]+q[i].d;\n\t\t\t\tif(!use[b]){use[b]=true;qq.push(b);}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b,c;\n\troot=maxn;int out=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(i,i-1,-1);\n\t\tadd(i-1,i,0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\troot=min(a-1,root);\n\t\tout=max(out,b);\n\t\tadd(a-1,b,c);\n\t}\n\tsp();\n\tprintf(\"%d\\n\",dis[out]);\n\treturn 0;\n}\n```\n\n差分约束算是非常复杂的方法\n这题其实可以用贪心来做(区间选点模型)\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTY3NTU2OTYzNl19\n-->","tags":["差分约束"],"categories":["算法学习"]},{"title":"军训队列","url":"/2018/10/23/军训队列/","content":" \n### 题意\n>有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方.现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？\n----\n- 排序\n- DP\n\n> **先将身高排序,问题就转换成将一个区间切成$k$段,求$k$个区间的极值差平方和的最小值\n对于每一个人,他的决策无非两种,加到上一个区间,或者自立门户,状态转移方程:**\n> 1. **加入上一个区间:** &nbsp;&nbsp;$f[i][j][k]=min(f[i-1][j][k]-v[j][i-1]+v[j][i])$\n> 2. **自立门户:**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f[i][i][k]=min(f[i-1][j][k-1])$\n> \n> **我们可以$n^2$预处理出v数组,时间复杂度为$(o)n^3$\n> 但问题又来了,空间复杂度是$n^3+n^2$,可能开不下\n> 我们观察到$i$维每次有用的状态只有两位,我们可以用一个滚动数组优化空间,空间复杂度变为$3\\times n^2$**\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=510;\nint n,m,h[maxn],cnt;\nint f[2][maxn][maxn];\nint v[maxn][maxn];\nint main()\n{\n\tfreopen(\"queue.in\",\"r\",stdin);\n\tfreopen(\"queue.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&h[i]);\n\tif(n==m)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tsort(h+1,h+1+n);memset(f,0x3f,sizeof f);\n\tfor(int i=1;i<=n;i++)for(int j=i;j<=n;j++)\n\tv[i][j]=(h[j]-h[i])*(h[j]-h[i]);\n\tf[0][0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt^=1;memset(f[cnt],0x3f,sizeof f[cnt]);\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=m;k++)\n\t\t\t{\n\t\t\t\tf[cnt][i][k]=min(f[cnt][i][k],f[cnt^1][j][k-1]);\n\t\t\t\tf[cnt][j][k]=min(f[cnt][j][k],f[cnt^1][j][k]-v[j][i-1]+v[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1e9+7;\n\tfor(int i=1;i<=n;i++)\n\tans=min(ans,f[cnt][i][m]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTU3MjAzNjcwMV19\n-->","tags":["线性DP"],"categories":["算法学习"]},{"title":"分块","url":"/2018/10/23/分块/","content":"\n### 题意\n\n> $n$个格子，现在要把它分成若干段相邻的块，要求每块不超过$m$个格子。块数不限。求分法总数对$Q$取模的结果。\n\n### 题解\n\n> **首先想到$n^2$ 的做法,我们定义$f[i]$表示划分到$i$时的合法方案的数量,不难想到转移方程:$$f[i]= \\sum_{j=max(0,i-m)}^{i-1}f[j]$$ \n> 复杂度是$(0)n^2$\n> 然而数据范围是$10^6$,我们需要继续优化;\n> 观察转移方程我们发现$f[i]$实际上等于一段连续区间的和,我们可以用前缀和来优化DP,这样时间复杂度就降到了$(o)n$,这道题就解决了**\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1e6+10;\nint t,n,m,mod;\nll f[maxn],s[maxn];\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d%d\",&n,&m,&mod);\n\t\tmemset(f,0,sizeof f);\n\t\tf[0]=1;s[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(!(i-m))f[i]=s[i-1];\n\t\t\telse f[i]=(s[i-1]-s[i-m-1])%mod;//记得取模\n\t\t\ts[i]=(s[i-1]+f[i]);\n//\t\t\tfor(int j=max(0,i-m);j<i;j++)\n//\t\t\tf[i]+=f[j];\n\t\t}\n\t\tprintf(\"%lld\\n\",f[n]);\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTM0ODY2MjYwNV19\n-->","tags":["线性DP"],"categories":["算法学习"]},{"title":"刷油漆","url":"/2018/10/23/刷油漆/","content":"\n### 题意\n> cxm 需要给一块长木板刷上油漆。他一次可以将一段的木板刷上同一种颜色，刷过的木板可以再刷成其他颜色。现在木板被分成了若干块，每块需要涂成一个确定的颜色。 cxm 希望你告诉他最少需要涂几次就可以将每块都涂成需要的颜色。\n\n- 区间DP\n- $turn$函数比较迷\n- 有十分有毒~(学长有毒)~\n\n还是比较简单的区间DP,就是在区间DP基础上加了一个$turn$\n虽然我没搞懂$turn$~~(但我拿了90,滑稽)~~\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2010;\nint n,t,s[maxn];\nint f[maxn][maxn];\nint turn(int a,int b,int c)\n{\n\tif(s[a]==s[b]||s[a]==s[c+1]||s[c]==s[b]||s[c]==s[c+1])return -1;\n\treturn 0;\n}\nint main()\n{\n\tfreopen(\"paint.in\",\"r\",stdin);\n\tfreopen(\"paint.out\",\"w\",stdout);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tmemset(f,0x3f,sizeof f);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t \tscanf(\"%d\",&s[i]);\n\t\t \tf[i][i]=1;\n\t\t}\n\t\tfor(int l=1;l<=n;l++)for(int i=1;i+l<=n;i++)\n\t\t{\n\t\t \tint j=i+l;for(int k=i;k<j;k++)\n\t\t \tf[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+turn(i,j,k));\n\t\t}\n\t\tprintf(\"%d\\n\",f[1][n]);\n\t}\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbODkxMjY4MjZdfQ==\n-->","tags":["区间DP"],"categories":["算法学习"]},{"title":"割点和桥学习","url":"/2018/10/23/割点和桥 学习/","content":"\n----  \n说实话,tarjan是个好东西\n然而我却丢了他的脸\n到现在我还是很迷糊\n- 注意缩点,割点和割边的不同\n- 这东西有毒,剧毒~~mmp~~\n- 割点\n- 割边\n  - 当存在重边时应将记录父亲节点改为记录父亲边\n- 点双联通分量\n- 边双联通分量\n  - 可在求割边时同时求出\n- tarjan\n\n```cpp\n//割边 && 没有重边\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=5e3+10;\nint n,m,head[maxn],num;\nint dfn[maxn],low[maxn],input;\nbool use[maxn];\nstruct fy{int to,next;}q[maxn<<2];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nvoid tar(int a,int fa)\n{\n\tdfn[a]=low[a]=++input;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(!dfn[b])\n\t\t{\n\t\t\ttar(b,a);low[a]=min(low[a],low[b]);\n\t\t\tif(dfn[a]<low[b])use[i]=true;//感觉这个地方这辈子都不会懂了,太迷幻\n\t\t\t//当然可以和割点一起求\n\t\t\t/*if((child>1&&root==a)||(root!=a&&dfn[a]<=low[b])cutd[i]=true;*/\n\t\t\t//root为根节点\n\t\t}\n\t\telse if(b!=fa)low[a]=min(low[a],dfn[b]);\n\t\t//为什么是b!=fa呢,不懂\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);add(b,a);\n\t}\n\tfor(int i=1;i<=n;i++)if(!dfn[i])tar(i,0);\n\tfor(int i=1;i<=num;i++)if(use[i])printf(\"%d \",i);\n\treturn 0;\n}\n```\n\n当有重边时记录父亲**边**\n```cpp\n//割边&&边双缩点&&有重边&&非边双转边双\n#include<cstdio>\n#include<stack>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=5e3+10;\nint n,m,head[maxn],num,bi,cnt,ans,fa[maxn],in[maxn];\nbool use[maxn<<2];\nint dfn[maxn],low[maxn],input,xx[maxn],w,pa[maxn];\nstruct fy{int from,to,next,h;}q[maxn<<2];\n//h用来装边\nvoid add(int a,int b)\n{\n\tq[++num]=(fy){a,b,head[a],++bi};head[a]=num;\n\tq[++num]=(fy){b,a,head[b],bi};head[b]=num;\n}\nvoid tar(int a)\n{\n\tdfn[a]=low[a]=++input;xx[++w]=a;\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(q[i].h==pa[a])continue;//如果该边走过了就不能再走\n\t\tif(!dfn[b])\n\t\t{\n\t\t\tpa[b]=q[i].h;//记录父亲边\n\t\t\ttar(b);low[a]=min(low[a],low[b]);\n\t\t}\n\t\telse low[a]=min(low[a],dfn[b]);\n\t}\n\tif(dfn[a]==low[a])//同时边双缩点\n\t{\n\t\tcnt++;\n\t\twhile(xx[w+1]!=a)\n\t\t{fa[xx[w]]=cnt;w--;}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int a,b;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);\n\t}\n\ttar(1);\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\ta=fa[q[i].from];\n\t\tb=fa[q[i].to];\n\t\tif(a!=b)in[b]++;\n\t}\n\tfor(int i=1;i<=cnt;i++)if(in[i]==1)ans++;\n\tprintf(\"%d\\n\",(ans+1)/2);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTExMjM0NDMxMTFdfQ==\n-->","tags":["tarjan"],"categories":["算法学习"]},{"title":"信息技术培训基础知识","url":"/2018/10/23/基础知识/","content":"  \n### 一、高精度计算\n（至少掌握加减乘（高精对高精），正数高精度（简化模板）加减乘除（高精度与低精度）  \n### 二、排序算法  \n基本算法（选择排序、插入排序、冒泡排序、快排、堆排、归并排序、计数排序、基数排序。另外练习字符串排序、多关健字排序、排序二叉树）  \n典型应用  \n逆序对、第K小数  \n### 三、查找算法  \n数组映射、顺序查找、二分查找（一般静态）、hash查找（可动态也可静态、编码）  \n### 四、递归、回溯、深搜  \n从相关题目加深理解  \n最大公约数（减法和求余）、排列数的输出、组合数的输出、表达式计算、逆波兰式、连续最大和（递归）、上台阶问题、跳马问题、填数问题、老鼠走迷宫、因式分解、素数环、皇后问题、机器分工、数的划分、任务安排、四色问题、邮票问题、埃及分数、生日蛋糕、八数码问题、路由选择。（迭代思想、剪枝技巧、IDA*、阶乘编码）  \n### 五、广搜  \n魔板问题、跳棋问题、八数码问题、奇怪的电梯、翻硬币问题。（相关的优化，加快判重、双向搜索、IDA*）  \n### 六、二分  \n二分加速、二分查找、二分枚举  \n### 七、数据结构  \n栈（表达式计算）、队列（广搜中常用、单调队列）、链表、双向链表、堆、竞赛树、排序二叉树、树状数组、hash、并查集、KMP算法、RMQ、LCA、回文串问题、trie。（树的线型化应用、深搜序的应用）  \n### 八、图论  \n图的两种遍历方式、图的连通性判别定（深搜索、并查集）、有向图的强连通分量（两次深搜求交法、tarjan)、拓朴排序、关键路、最短路算法（dijk、floyd、bellman、spfa)、最小生成树（prime、Kruskal）二分匹配（最大独立集、最小支配集、最小路径点覆盖问题）（题库上题目较多）欧拉路和欧拉回路、哈密顿回路、关节点、桥  \n  \n### 九、动态规划  \n（重中之重 练习相关基本模型）  \n  \n  \n### 重要思想：\n二分、逆向思维\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTg2OTgyMzE1XX0=\n-->","tags":["总结"],"categories":["算法学习"]},{"title":"字符串的最小表示","url":"/2018/10/23/字符串的最小表示/","content":"\n> **开两个指针,依次对比;\n> 当第二个指针比第一个更优时,更新第一个指针为第二个指针,第二个指针+1**\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=3e5+10;\nint n;\nchar str[maxn];\nint l,w;\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%d%s\",&l,str);\n\t\tfor(int i=0;i<l;i++)\n\t\tstr[i+l]=str[i];\n\t\tint ll=0,rr=1;\n\t\twhile(ll<l&&rr<l)\n\t\t{\n\t\t\tint i=0;\n\t\t\twhile(str[ll+i]==str[rr+i]) i++;\n\t\t\tif(i>=l) break;\n\t\t\tif(str[ll+i]>str[rr+i]) \n\t\t\t{\n\t\t\t\tif(ll+i+1>rr) ll=ll+i+1;\n\t\t\t\telse ll=rr+1;\n\t\t\t}\n\t\t\telse if(rr+1+i>ll) rr=rr+i+1;\n\t\t\telse rr=ll+1;\n\t\t}\n\t\tprintf(\"%d\\n\",min(ll,rr));\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTc0ODczOTE1MF19\n-->","tags":["字符串"],"categories":["算法学习"]},{"title":"排队接水","url":"/2018/10/23/排队接水/","content":" \n### 题意\n\n>\t现在一个水龙头前面有 n 个人需要接水，他们的编号为 1 到 n 的整数。他们每个人有各自接水需要花费的时间，其中编号为 i 的人花费的时间为 Ti。另外每个人有各自的紧急程度，编号为 i 的人紧急程度为 Ei。现在我们需要给所有人排出一个序，使得总不和谐程度最低。我们定义一个人的等待时间为排在他前面的人和这个人花费的时间之和，一个人的不和谐程度为这个人的等待时间乘以这个人的紧急程度，总不和谐程度为所有人的  \n不和谐程度的和。  \n即我们需要求出一个 1 到 n 的排列 faig ，使得 $\\sum_{i=1}^n( \\sum^n _{j=1} T_{a_j} )$ 最小。\n\n- 贪心 \n- 然后没了\n- 类似`国王游戏`\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=2e5+10;\nint n,t;\nll ans,s;\nstruct fy\n{\n\tint t,v;double s;\n\tvoid w(){this->s=(double)this->t/(double)this->v;}\n\tbool operator<(const fy&a)\n\tconst{return s<a.s;}\n}q[maxn];\nint read()\n{\n \tint k=0,f=0;char c=getchar();for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;\n \tfor(;c<='9'&&c>='0';c=getchar())k=(k<<3)+(k<<1)+c-'0';return  f?-k:k;\n}\nint main(){\n \tfreopen(\"water.in\",\"r\",stdin);\n \tfreopen(\"water.out\",\"w\",stdout);\n \tt=read();\n \twhile(t--)\n \t{\n \t\tn=read();ans=0;s=0;\n \t\tfor(int i=1;i<=n;i++)\n\t\t {q[i].t=read();q[i].v=read();q[i].w();}\n \t\tsort(q+1,q+1+n);\n \t\tfor(int i=1;i<=n;i++)\n \t\t{\n \t\t\ts+=q[i].t;\n \t\t\tans+=(ll)s*(ll)q[i].v;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n \treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTU3NjI5NTQ0Nl19\n-->","tags":["贪心"],"categories":["算法学习"]},{"title":"摆花","url":"/2018/10/23/摆花/","content":"\n### 题意\n> 有$n$种花,每种有$a_i$盆,要摆$m$盆,每种花连续并且编号大的在后.求有多少种摆法\n\n### 题解\n> **一道简单的计数DP.\n> 我们定义$f[i][j]$表示放第$i$种花时一共放了$j$盆时的方案数,那么状态转移方程:**$$f[i][j]=\\sum_{k=0}^{a[i]} f[i-1][j-k]$$\n\n- $f[0][0]=1$\n- $j>=k$\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=110,mod=1e6+7;\nint n,m,f[maxn][maxn],a[maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);f[0][0]=1;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=0;j<=m;j++)\n\tfor(int k=0;k<=a[i];k++)if(j>=k)\n\tf[i][j]=(f[i][j]+f[i-1][j-k])%mod;\n\tprintf(\"%d\\n\",f[n][m]);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTI1NjgwMDk5OF19\n-->","tags":["计数DP"],"categories":["算法学习"]},{"title":"「一本通 1.1 例 5」智力大冲浪","url":"/2018/10/23/智力挑战/","content":"\n### 题解\n\n> - 带限期和罚款的单位时间任务调度\n>     - 按期限排序\n>  \t- 用优先队列维护\n>  \t- 若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队\n>  \t- 若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队\n>  \t- 最后累加队列中的元素权值,$v$减去这个和即为答案\n\n### Coding:\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e3+10;\nint n,l,v,ans;\nstruct fy\n{\n\tint x,y;\n\tbool operator<(const fy&a)\n\tconst{return x<a.x;};\n}q[maxn];\nstruct ffy\n{\n\tint x;\n\tbool operator<(const ffy&a)\n\tconst{return x>a.x;}\n};\npriority_queue<ffy>qq;\nint main()\n{\n\tscanf(\"%d%d\",&v,&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&q[i].x);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&q[i].y);\n\t\tans+=q[i].y;\n\t}\n\tsort(q+1,q+1+n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=q[i].x;\n\t\tint b=q[i].y;\n\t\tif(l<a)\n\t\t{\n\t\t\tqq.push((ffy){b});\n\t\t\tl++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tint c=qq.top().x;\n\t\t\tif(b>c)\n\t\t\t{\n\t\t\t\tqq.pop();\n\t\t\t\tqq.push((ffy){b});\n\t\t\t}\n\t\t}\n\t}\n\twhile(!qq.empty())\n\t{\n\t\tans-=qq.top().x;\n\t\tqq.pop();\n\t}\n\tprintf(\"%d\\n\",v-ans);\n\treturn 0;\n}\n```\n","tags":["贪心"],"categories":["一本通"]},{"title":"核电站问题","url":"/2018/10/23/核电站问题/","content":"\n### 题意\n> 一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续M个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质.现在，请你计算：对于给定的N和M，求不发生爆炸的放置核物质的方案总数。\n\n### 题解\n> **很简单的一道DP,我们定义$F[i][j]$表示第$i$个坑已经连续装了$j$个核物质,那么状态无外乎两种:** \n> 1. 下一个坑继续装\n> 2. 下一个坑不装\n> \n> **答案就是$\\sum_{i=0}^mF[n][i]$**\n\n- 当连续放$m$个坑的时候,就会发生爆炸,所以$m$应该减一\n- 初始条件是$F[0][0]=1$\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=110;\nint n,m;\nll f[maxn][10];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tf[0][0]=1;m--;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=m;j++)\n\t\tf[i][0]+=f[i-1][j];\n\t\tfor(int j=1;j<=m;j++)\n\t\tf[i][j]+=f[i-1][j-1];\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=m;i++)ans+=f[n][i];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTEwMDIyMjk0M119\n-->","tags":["线性DP"],"categories":["算法学习"]},{"title":"灯泡","url":"/2018/10/23/灯泡/","content":"\n### 题意\n> 求$L$最大值\n> \n\n![asdfasdf](http://acm.zju.edu.cn/onlinejudge/showImage.do?name=light_bulb_1037_ddd01.gif)\n\n> **我们设人与灯低的距离为$x$,墙上的部分长$y$,用$x$表示出$L$和$y$,通过均值不等式求解最大值**\n\n```cpp\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint t;\ndouble H,h,D;\ndouble cal()\n{\n\tdouble x=sqrt((H-h)*D);//均值不等式成立条件\n\tx=min(x,D);//x右边界\n\tx=max(x,(D*H-D*h)/H);//x左边界\n\treturn D+H-x-(H-h)*D/x;\n}\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%lf%lf%lf\",&H,&h,&D);\n\t\tprintf(\"%.3lf\\n\",cal());\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE5MTM4MzgyMThdfQ==\n-->","tags":["均值不等式"],"categories":["算法学习"]},{"title":"烽火传递","url":"/2018/10/23/烽火传递/","content":"\n### 题意\n>在某两座城市之间有 n 个烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确的传递，在任意相邻的 m 个烽火台中至少要有一个发出信号。现在需要计算总共最少需要花费多少代价，才能使敌军来袭之时，情报能在这两座城市之间准确的传递。\n- 单调队列优化 \n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10,inf=1e9+7;\nint n,t,m,f[maxn][2],v[maxn];\nint q[maxn<<1],p[maxn<<1];\nint main()\n{\n\tfreopen(\"flame.in\",\"r\",stdin);\n\tfreopen(\"flame.out\",\"w\",stdout);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]); \n\t\tint t=0,h=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{ \n\t\t\tint a=0;\n\t\t\tif(i-p[h]>m)h++;\n\t\t\tif(i>m)a=v[i]+q[h];else a=v[i];\n\t\t\twhile(t>=h&&q[t]>a)t--; \n\t\t\tq[++t]=a;p[t]=i;\n\t\t}\n\t\tint ans=inf;\n\t\tif(n-p[h]>=m)h++;\n\t\tfor(int i=max(h,t-m+1);i<=t;i++)\n\t\tans=min(ans,q[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n---\n可以加一位n+1,直接作为ans,省去后面的ans统计<br>\n可以省去一些麻烦(~~比如3个小时~~)\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e5+10,inf=1e9+7;\nint n,t,m,f[maxn][2],v[maxn];\nint q[maxn<<1],p[maxn<<1];\nint main()\n{\n\tfreopen(\"flame.in\",\"r\",stdin);\n\tfreopen(\"flame.out\",\"w\",stdout);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]); \n\t\tint t=0,h=1;\n\t\tfor(int i=1;i<=n+1;i++)//n+1\n\t\t{ \n\t\t\tint a=0;\n\t\t\tif(i-p[h]>m)h++;\n\t\t\tif(i>m)a=v[i]+q[h];else a=v[i];\n\t\t\twhile(t>=h&&q[t]>a)t--; \n\t\t\tq[++t]=a;p[t]=i;\n\t\t}\n\t\tprintf(\"%d\\n\",q[t]);//直接输出\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE3MDU4NzM2OThdfQ==\n-->","tags":["单调队列优化DP"],"categories":["算法学习"]},{"title":"球和盒子问题","url":"/2018/10/23/球和盒子问题/","content":"\n### 结论\n\n![](https://s1.ax1x.com/2018/10/12/itXzw9.jpg)\n\n- $F[i][j]=F[i-1][j-1]+j*F[i-1][j](F[1][1]=1)$\n- $G[i][j]=G[i][j-1]+G[i-j][j](G[0][i]=G[1][i]=G[i][1]=1)$\n- 注意各种情况的初始化\n\n### 1.放苹果\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=20;\nint t,n,m;\nint f[maxn][maxn];\nint main()\n{\n\tscanf(\"%d\",&t);\n\tfor(int i=0;i<=10;i++)f[0][i]=f[i][1]=f[1][i]=1;\n\tfor(int i=1;i<=10;i++)for(int j=2;j<=10;j++)\n\t{\n\t\tf[i][j]=f[i][j-1];\n\t\tif(i>=j)f[i][j]+=f[i-j][j];\n\t}\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tprintf(\"%d\\n\",f[n][m]);\n\t}\n\treturn 0;\n}\n```\n\n### 2.数的划分\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=210;\nint n,m;\nll f[maxn][maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n;i++)f[0][i]=f[1][i]=f[i][1]=1;\n\tfor(int i=2;i<=n;i++)for(int j=1;j<=m;j++)\n\t{\n\t\tf[i][j]=f[i][j-1];\n\t\tif(i>=j)f[i][j]+=f[i-j][j];\n\t}\n\tprintf(\"%lld\\n\",f[n-m][m]);\n\treturn 0;\n}\n```\n### 6.小朋友的球\n```cpp\n//这题要高精\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=110;\nint n,m;\nll f[maxn][maxn];\nint main()\n{\n\tf[1][1]=1;\n\tfor(int i=2;i<=100;i++)for(int j=1;j<=100;j++)\n\tf[i][j]=f[i-1][j-1]+f[i-1][j]*j;\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tprintf(\"%lld\\n\",f[n][m]);\n\t}\n\treturn 0;\n}\n```\n### 8.盒子和小球\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=20;\nint n,m,f[maxn][maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);f[1][1]=m;\n\tfor(int i=2;i<=n;i++)for(int j=1;j<=m;j++)\n\tf[i][j]=f[i-1][j-1]*(m-j+1)+f[i-1][j]*j;\n\tprintf(\"%d\\n\",f[n][m]);\n\treturn 0;\n}\n```\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=20;\nint n,m,f[maxn][maxn];\nint work(int a)\n{\n\tint ans=1;\n\tfor(int i=2;i<=a;i++)\n\tans*=i;\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);f[1][1]=1;\n\tfor(int i=2;i<=n;i++)for(int j=1;j<=m;j++)\n\tf[i][j]=f[i-1][j-1]+f[i-1][j]*j;\n\tprintf(\"%d\\n\",f[n][m]*work(m));\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMTA3ODk0NTYwNCwxNjc5NzYzNDE0XX0=\n-->","tags":["计数DP"],"categories":["算法学习"]},{"title":"贪心五种常见模型","url":"/2018/10/23/贪心五种常见模型/","content":"\n---\n### 1. 区间不相交问题\n\n> - 按右端点排序\n> - 枚举,当左端点未被标记时,$ans++$,标记右端点 \n---\n### 2. 区间选点问题\n\n> - 按右端点排序\n> - 枚举,当该区间未被选够点时,从后往前选择未被选择的点,直到选够\n---\n### 3. 区间覆盖问题\n\n> - 按左端点排序\n> - 枚举,选择能覆盖当前节点,右端点最远的节点,将当前节点更新为该最远节点的右端点\n---\n### 4. 流水作业调度问题\n\n> - Johnson算法(~~比较迷,反正我没懂~~)\n> - 按$min(i.a,j.b)<min(i.b,j.a)$排序\n> - 枚举记录$ans$\n---\n### 5. 带限期和罚款的单位时间任务调度\n\n> - 按期限排序\n> - 用优先队列维护\n> - 若当前时间完成的任务数少于该时间能完成的任务数,直接将权值入队\n> - 若已经相等,取出队列中最小的元素与当前权值比较,将较大的入队\n> - 最后累加队列中的元素权值\n\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMjA5OTg2OTc5NV19\n-->","tags":["贪心"],"categories":["算法学习"]},{"title":"过河","url":"/2018/10/23/过河/","content":"\n### 题意\n> [**P1052**  过河](https://www.luogu.org/problemnew/show/P1052)\n\n- 排序\n- 离散化\n- DP\n\n> **桥很长,不能直接DP;而石子数比较少,这时我们想到离散化;\n当两点间的距离$d$大于$t$时,一定可以由d%t跳过来,所以最多只需要t+d%t种距离的状态就可以表示这两个石子之间的任意距离关系.这样就把题目中的$10^9$压缩成了$2\\times t\\times m$最多不超过$2000$,然后就可以放心大胆地用DP了.不过要注意题目中的\"当青蛙跳到或跳过坐标为L的点时.就算青蛙已经跳出了独木桥\",所以DP的终点是一个范围而非确切的一个点，最后还要在这个范围内取最小值。**\n\n```cpp \n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=2e3+10;\nint l,s,t,m,n;\nint f[maxn],lo[200];\nbool use[maxn];\nint main()\n{\n\tscanf(\"%d%d%d%d\",&l,&s,&t,&m);\n\tmemset(f,0x3f,sizeof f);f[0]=0;\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&lo[i]);\n\tsort(lo+1,lo+1+m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(lo[i]-lo[i-1]>=t)n+=(lo[i]-lo[i-1])%t+t;\n\t\telse n+=(lo[i]-lo[i-1]);\n\t\tuse[n]=true;\n\t}\n\tn+=(l-lo[m])%t;\n\tfor(int i=1;i<=n+t-1;i++)\n\t{\n\t\tfor(int j=s;j<=t;j++)if(i-j>=0)\n\t\tf[i]=min(f[i],f[i-j]);\n\t\tif(use[i])f[i]++;\n\t}\n\tint ans=1e9;\n\tfor(int i=n;i<=n+t-1;i++)ans=min(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMjIyNTQyMTM3XX0=\n-->","tags":["线性DP"],"categories":["算法学习"]},{"title":"逐个击破","url":"/2018/10/23/逐个击破/","content":"\n### 题意\n> 现在有N个城市，其中K个被敌方军团占领了，N个城市间有N-1条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你K个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这K个地方军团互相隔离开，以便第二步逐个击破敌人。\n\n### 题解\n> **我们加一个辅助数组记录每个城市是否被占领,然后跑最大生成树.当且仅当两个城市所在的连通块都被占领时,我们不取这条边,其余时候将当前两个城市的占领属性合并,最后 $ans$=用总代价-最大生成树权值和**\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int maxn=1e5+10;\nint n,k,fa[maxn];\nll ans;\nbool ee[maxn];\nstruct fy\n{\n\tint from,to,d;\n\tbool operator<(const fy&a)\n\tconst{return d>a.d;};\n}q[maxn];\nint find(int a)\n{\n\twhile(a!=fa[a])a=fa[a]=fa[fa[a]];\n\treturn a;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tee[a]=true;\n\t}\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&q[i].from,&q[i].to,&q[i].d);\n\t\tans+=q[i].d;\n\t}\n\tsort(q+1,q+n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a=find(q[i].from);\n\t\tint b=find(q[i].to);\n\t\tif(ee[a]&&ee[b])continue;\n\t\tfa[a]=b;\n\t\tee[a]|=ee[b];ee[b]|=ee[a];//合并属性\n\t\tans-=q[i].d;\n\t} \n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbNjQ2MDkzNzk2XX0=\n-->","tags":["并查集"],"categories":["算法学习"]},{"title":"钓鱼","url":"/2018/10/23/钓鱼/","content":"\n### 题意\n> 一条路上有$N$个鱼塘,鱼塘$i$花5$min$可以钓$t_i$条鱼,但每钓一次能钓到的鱼数量会减去$s_i$,并且从鱼塘$i$走到鱼塘$i+1$会花费$5\\times dis_i$的时间.现在有$H$小时的时间,可以在任意鱼塘结束,求最多能钓多少条鱼\n\n### 题解\n> **非常巧妙的一道贪心题.\n我们枚举结束的鱼塘,用总时间减去路上花掉的时间,剩下的时间用来钓鱼.\n先将路上经过的鱼塘第一个5$min$能钓到的鱼条数加入优先队列,每次取出队列中最大元素的加入该鱼塘的答案,将该元素减去对应的$s_i$加入队列,直到时间用尽或者优先队列中最大值小于等于0,更新答案**\n\n- 注意时间的转化\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=110;\nint n,h,dis[maxn],ans,bns;\nint s[maxn],ss[maxn];\nstruct ffy\n{\n\tint x,y;\n\tbool operator<(const ffy&a)\n\tconst{return x<a.x;};\n};\npriority_queue<ffy>qq;\nint main()\n{\n\tscanf(\"%d%d\",&n,&h);h*=12;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&s[i]);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&ss[i]);\n\tfor(int i=2;i<=n;i++)scanf(\"%d\",&dis[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\th-=dis[i];int time=0;bns=0;\n\t\tfor(int j=1;j<=i;j++)qq.push((ffy){s[j],j});\n\t\twhile(++time<=h&&!qq.empty())\n\t\t{\n\t\t\tint a=qq.top().x;\n\t\t\tint b=qq.top().y;\n\t\t\tif(a<=0)break;\n\t\t\tbns+=a;\n\t\t\tqq.pop();\n\t\t\tqq.push((ffy){a-ss[b],b});\n\t\t}\n\t\tans=max(ans,bns);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbMzYyNzgzMzY1XX0=\n-->","tags":["贪心 - 单调队列"],"categories":["算法学习"]},{"title":"铺地板","url":"/2018/10/23/铺地板/","content":"\n### 题意\n> NS 中学新建了一个 n × n 的正方形广场，现在需要你用 1 × 2 的地板砖去铺这个广场。由于各种原因，广场上有些地方不能铺地板（比如那里种了一棵树或者有一个井盖）。显然，地板也不能重叠放置. 现在你需要求出最少有多少个格子不能被地板铺上（包括不能铺地板的地方）。\n\n- 看出二分图\n- 然后 $AC$ ~(滑稽)~\n\n只要看出是二分图模型就非常简单\n建双向边得出的$ans$最大匹配的二倍\n但因为一条边连接两个点所以直接输出$n^2-ans$\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=70;\nint n,head[maxn*maxn],num,p[maxn*maxn];\nint cnt,t,map[maxn][maxn];\nbool use[maxn*maxn];\nint mx[4]={0,0,-1,1};\nint my[4]={1,-1,0,0};\nchar str[maxn];\nstruct fy{int to,next;}q[maxn*maxn*10];\nvoid add(int a,int b){q[++num]=(fy){b,head[a]};head[a]=num;}\nbool find(int a)\n{\n\tfor(int i=head[a];i;i=q[i].next)\n\t{\n\t\tint b=q[i].to;\n\t\tif(!use[b])\n\t\t{\n\t\t\tuse[b]=true;\n\t\t\tif(!p[b]||find(p[b]))\n\t\t\t{\n\t\t\t\tp[b]=a;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\tfreopen(\"floor.in\",\"r\",stdin);\n\tfreopen(\"floor.out\",\"w\",stdout);\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);memset(head,0,sizeof head);\n\t\tcnt=0;num=0;memset(map,0,sizeof map);\n\t\tmemset(p,0,sizeof p);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%s\",str);\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\tif(str[j]=='.')map[i][j+1]=++cnt;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t\tif(map[i][j])\n\t\t{\n\t\t\tint a=map[i][j];\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint b=map[i+mx[k]][j+my[k]];\n\t\t\t\tif(b)add(a,b);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=cnt;i++)\n\t\t{\n\t\t\tmemset(use,false,sizeof use);\n\t\t\tif(find(i))ans++;\n\t\t}\n\t\tprintf(\"%d\\n\",n*n-ans);\n\t}\n\treturn 0;\n}\n```\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTE0NTYyNTc3MzBdfQ==\n-->","tags":["二分图"],"categories":["算法学习"]},{"title":"about","url":"/about/index.html","content":"# 居然有人点开了这个页面 (ΩДΩ)\n\n可能是你点错了,毕竟我这么菜,\n谁会来看我呢~~(滑稽)~~\n\n![](https://s1.ax1x.com/2018/10/24/ir5US0.png)\n\n本人一名**小蒟蒻**,在各位大佬间苦苦挣扎,苟且偷生~~(宝宝心里苦,难受,香菇)~~\n\n不喜欢打游戏(偶尔玩玩),喜欢搞一些计算机上奇奇怪怪的东西(对,就是老师和爸妈口中的\"不务正业\",\"没名堂的东西\",\"浪费时间\")\n\n喜欢二次元,喜欢宅在家里的穷学生\n\n![ir5ITH.gif](https://s1.ax1x.com/2018/10/24/ir5ITH.gif)\n\n学过一点点C++和Java,算法也有一点涉猎(请记住,是一点点,就像你对于地球那样的一点点),当然没有办法和各位大佬比\n\n![ir5Dw4.gif](https://s1.ax1x.com/2018/10/24/ir5Dw4.gif)\n\n还是一位OIer,虽然马上退役了,好吧,像我这种弱鸡,根本不能说退役,是根本没入役\n\n![ir5yk9.jpg](https://s1.ax1x.com/2018/10/24/ir5yk9.jpg)\n\n好吧,了解了我的菜之深后,你肯定也不想继续看下去了,但我还是厚颜无耻的写下我的联系方式\n\nQQ: \n> 1836017424\n\nEmail: \n> 1836017424@qq.com \n>\n> scaryffy@gmail.com\n\n你如果有问题,可以通过上面的方式联系我(可能这辈子都不会有了)\n\n在下学生,不能保证及时回复,但我看到了一定会回复\n\n![ir550e.jpg](https://s1.ax1x.com/2018/10/24/ir550e.jpg)\n\n我的名一个[Blog](https://ffdy.coding.me/ffdy),用next主题\n\n### 愿幸运与你同在\n\n但如果你有上条当麻的右手,我还真没办法\n\n至此"},{"title":"links","url":"/links/index.html"},{"title":"tags","url":"/tags/index.html"}]